REBOL[	Title:		"OpenCV Binding: core_c"	Author:		"François Jouen"	Rights:		"Copyright (c) 2014 François Jouen. All rights reserved."	License: 	"BSD-3 - https:;github.com/dockimbel/Red/blob/master/BSD-3-License.txt"];/****************************************************************************************\;*          Array allocation, deallocation, initialization and access to elements         *;\****************************************************************************************/;/* <malloc> wrapper.;If there is no enough memory, the function (as well as other OpenCV functions that call cvAlloc raises an error. */cvAlloc: cvFunc [	size    [integer!]    return: [string!]] core "cvAlloc";/* <free> wrapper.cvFree: cvFunc [	ptr		[integer!]] core "cvFree_";Rebol Specific ; normally we have to use a CvSize! structure to creates images or header; but rebol returns a block of value so we used 2 integers (width and height)cvCreateImageHeader: cvFunc  ["Allocates and initializes IplImage header"	width 		[integer!]	; CvSize/width	height 		[integer!]	; CvSize/height	depth		[integer!]	channels    [integer!]	return: 	[ptr!] 		;returns an iplImage structure]core "cvCreateImageHeader"cvInitImageHeader: cvFunc  ["Inializes IplImage header"	image		[ptr!] 			; IplImage!	width 		[integer!]		; CvSize/width	height 		[integer!]		; CvSize/height	depth		[integer!]	channels	[integer!]	origin		[integer!]		;CV_DEFAULT(0)	align		[integer!]		;CV_DEFAULT(4)	return: 	[ptr!] 			;returns an iplImage structure]core "cvInitImageHeader"cvCreateImage: cvFunc ["Creates IPL image (header and data);create new image"	width 		[integer!]	; CvSize/width	height 		[integer!]	; CvSize/height	depth 		[integer!]	channels 	[integer!]	return: 	[ptr!] ; returns an iplImage structure] core "cvCreateImage"cvReleaseImageHeader: func [image] [	image		[ptr!] ; double pointeur]cvReleaseImage: cvFunc ["Releases IPL image header and data"	image		[ptr!] ; IplImage! ; double pointer to IplImage** image	] core "cvReleaseImage"cvCloneImage: cvFunc ["Creates a copy of IPL image (widthStep may differ) "	image		[ptr!] 						; IplImage!	return: 	[ptr!] ; returns an iplImage structure] core "cvCloneImage"cvSetImageCOI: cvFunc [{Sets a Channel Of Interest (only a few functions support COI)use cvCopy to extract the selected channel and/or put it back}	image		[ptr!] 		; IplImage!    coi			[integer!]] core "cvSetImageCOI"cvGetImageCOI: cvFunc  ["Retrieves image Channel Of Interest"	image		[ptr!] 		; IplImage!	return:		[integer!]] core "cvGetImageCOI"cvSetImageROI: cvFunc  ["Sets image ROI (region of interest) (COI is not changed)"	image		[ptr!] 		; IplImage!		rect_x		[integer!]  ; CvRect/x     rect_y		[integer!]	; CvRect/y    rect_w		[integer!]  ; CvRect/width     rect_h		[integer!]  ; CvRect/height ]core "cvSetImageROI"cvResetImageROI: cvFunc ["Resets image ROI and COI"	image		[ptr!] ; IplImage!] core "cvResetImageROI";OpenCVcvGetImageROI_: cvFunc ["Retrieves image ROI"	image		[ptr!] ; IplImage! 	return: 	reduce [integer! integer! integer! integer!] ; CvRect not a pointer] core "cvGetImageROI" cvGetImageROI: func [image [integer!]] [	; get values associated to IplImage	pointer		blocValues: getPointerValues image IplImage!	ptr: blocValues/roi ; ROI value	; No Roi : all window	if ptr = 0 [            roi: 0        	coi: 0        	xOffset: 0        	yOffset: 0        	width: blocValues/width; image/width         	height: blocValues/height ; image/height     ]    ; we get a roi    if ptr <> 0 [    	roiValues: get-memory ptr 24    	coi: to-integer copy/part roiValues 4    	roiValues: skip roiValues 4        xOffset: to-integer copy/part roiValues 4        roiValues: skip roiValues 4        yOffset: to-integer copy/part roiValues 4        roiValues: skip roiValues 4        width: to-integer copy/part roiValues 4        roiValues: skip roiValues 4        height: to-integer copy/part roiValues 4    ]     reduce [xOffset yOffset width height]    ]cvCreateMatHeader: cvFunc [ "Allocates and initalizes CvMat header"	rows		[integer!]	cols		[integer!]	type		[integer!]	return:		[ptr!]		;cvMat]core "cvCreateMatHeader"CV_AUTOSTEP:  to-integer #7fffffffcvInitMatHeader: cvFunc  [ "Initializes CvMat header"	mat			[ptr!] 		; CvMat!	rows		[integer!]	cols		[integer!]	type		[integer!]	data    	[ptr!] 		;  ; void* pointer	step		[integer!] 	; CV_DEFAULT(CV_AUTOSTEP)	return:		[ptr!]] core "cvInitMatHeader"  cvCreateMat: cvFunc  ["Allocates and initializes CvMat header and allocates data" 	rows		[integer!] 	cols		[integer!] 	type 		[integer!] 	return:		[ptr!]]core "cvCreateMat" ;OpenCVcvReleaseMat: cvFunc  ["Releases CvMat header and deallocates matrix data (reference counting is used for data)"	mat		 [ptr!] ; double pointer] core "cvReleaseMat";/* Decrements CvMat data reference counter and deallocates the data if it reaches; inline function, not included in library. ;use pointer to CvMat! To be tested with Rebol !!!!cvDecRefData: func  [mat][    if  (CV_IS_MAT mat)    [        mat/data: none        if (mat/refcount != none)  and (mat/refcount = 0) [cvFree [mat/refcount]        mat/refcount: none]    ]     if (CV_IS_MATND mat)    [        mat/data: none        if (mat/refcount != none)  and (mat/refcount = 0) [cvFree [mat/refcount]        mat/refcount: none]    ]];Increments CvMat data reference counter */cvIncRefData: func  [mat][    refcount: 0    if  (CV_IS_MAT mat)    [        if (mat/refcount != none) [refcount: refcount + 1 mat/refcount: refcount]    ]    if (CV_IS_MATND mat)    [       if (mat/refcount != none) [refcount: refcount + 1 mat/refcount: refcount]    ]    return refcount]cvCloneMat: cvFunc  ["Creates an exact copy of the input matrix (except, may be, step value)"	mat			[ptr!] 		; CvMat!	return:		[ptr!]] core "cvCloneMat"cvGetSubRect: cvFunc  ["Makes a new matrix from <rect> subrectangle of input array No data is copied"	arr			[ptr!] 		; CvArr! 	submat		[ptr!] 		; CvMat!	rect_x		[integer!]  ; CvRect/x     rect_y		[integer!]	; CvRect/y     rect_w		[integer!]	; CvRect/width    rect_h		[integer!]	; CvRect/height 	return:		[ptr!]]core "cvGetSubRect"alias 'cvGetSubRect "cvGetSubArr"cvGetRows: cvFunc  ["Selects row span of the input array: arr(start_row:delta_row:end_row (end_row is not included into the span)"	arr			[ptr!] 		; CvArr!;pointer to generic array	submat		[ptr!] 		; CvMat!	start_row   [integer!]	end_row		[integer!]	delta_row	[integer!] ; CV_DEFAULT(1)	return:		[ptr!]]core "cvGetRows"; inline functioncvGetRow: func [arr submat row] [return cvGetRows arr submat row row + 1 1]cvGetCols: cvFunc  ["Selects column span of the input array: arr(:,start_col:end_col) (end_col is not included into the span)"	arr			[ptr!] 		; CvArr!;pointer to generic array	submat		[ptr!] 		; CvMat!	start_col	[integer!]	end_col		[integer!]	return:		[ptr!]] core "cvGetCols"; inline functioncvGetCol:func [arr submat col] [return cvGetCols arr submat col col + 1];Select a diagonal of the input array.;(diag = 0 means the main diagonal, >0 means a diagonal above the main one,;<0 - below the main one).;The diagonal will be represented as a column (nx1 matrix).cvGetDiag: cvFunc  ["Select a diagonal of the input array"	arr			[ptr!] 		; CvArr!;pointer to generic array;	submat		[ptr!] 		; CvMat!	diag		[integer!]	;CV_DEFAULT(0)	return:		[ptr!]]core "cvGetDiag"cvScalarToRawData: cvFunc  ["low-level scalar <-> raw data conversion functions"	scalar			[ptr!]	; pointer to CvScalar	data			[ptr!];  *void pointer	type			[integer!]	extend_to_12	[integer!];CV_DEFAULT(0)] core "cvScalarToRawData"cvRawDataToScalar: cvFunc  [	data			[ptr!]; *void pointer	type			[integer!]	scalar			[ptr!] ; pointer to CvScalar	return:			[]] core "cvRawDataToScalar";Allocates and initializes CvMatND headercvCreateMatNDHeader: cvFunc  [	dims			[integer!]	sizes			[ptr!] 		; pointer to an array of values 	type			[integer!]	return:			[ptr] ; return pointer to CVMatND] core"cvCreateMatNDHeader"cvCreateMatND: cvFunc  ["Allocates and initializes CvMatND header and allocates data"	dims		[integer!]	sizes		[ptr!] 			; pointer to an array of values 	type		[integer!]	return:		[ptr] ; return pointer to CVMatND]core "cvCreateMatND"cvInitMatNDHeader: cvFunc  ["Initializes preallocated CvMatND header"	mat			[ptr!]    ;;CvMatND!	dims		[integer!]	sizes		[ptr!] ; ptr! pointer	type		[integer!]	data		[integer!]; *void  CV_DEFAULT(NULL)	return:		[ptr] ; return pointer to CVMatND]core "cvInitMatNDHeader";inline Releases CvMatND: use CvMatND** mat as parametercvReleaseMatND: func [mat] [cvReleaseMat mat]                                cvCloneMatND: cvFunc  ["Creates a copy of CvMatND (except, may be, steps)"	mat		[ptr!]	;CvMatND!	return:	[ptr] ; return pointer to CVMatND] core "cvCloneMatND"cvCreateSparseMat: cvFunc ["Allocates and initializes CvSparseMat header and allocates data"	dims		[integer!]	sizes		[ptr!] ; ptr! pointer	type		[integer!]	return:		[ptr!] ;CvSparseMat]core "cvCreateSparseMat" ;OpenCV                                    cvReleaseSparseMat: cvFunc  ["Releases CvSparseMat"	mat [ptr!] ;CvSparseMat** mat double pointer]core "cvReleaseSparseMat"cvCloneSparseMat: cvFunc  ["Creates a copy of CvSparseMat (except, may be, zero items)"	mat 		[ptr!]	;  CvSparseMat!	return: 	[ptr!] ;CvSparseMat]core "cvCloneSparseMat";opencvcvInitSparseMatIterator_: cvFunc  ["Initializes sparse array iterator (returns the first node or NULL if the array is empty)"	mat 			[ptr!]			;CvSparseMat	mat_iterator	[ptr!]			;CvSparseMatIterator	return: 		[ptr!]			;CvSparseNode]core "cvInitSparseMatIterator";; rebol : use struct!cvInitSparseMatIterator: func [mat iterator] [	node: make struct! CvSparseNode! none	iterator/mat/type: mat/type	iterator/mat/dims: mat/dims	iterator/mat/refcount: mat/refcount	iterator/mat/refcount: mat/refcount	iterator/mat/heap: mat/heap	iterator/mat/hashtable: mat/hashtable	iterator/mat/hashsize: mat/hashsize	iterator/mat/valoffset: mat/valoffset	iterator/mat/idxoffset: mat/idxoffset	iterator/mat/size: mat/size	iterator/node/hashval: node/hashval	iterator/node/next: node/next	iterator/curidx: 1	node/hashval: iterator/node/hashval	node/next: iterator/node/next	node]cvGetNextSparseNode: func [mat_iterator][{returns next sparse array node (or NULL if there is no more nodes)inline function uses CvSparseMatIterator! as parameter and returns  CvSparseNode! }    either (mat_iterator/node/next) [return mat_iterator/node: mat_iterator/node/next]    [        idx: 0;        for idx mat_iterator/curidx mat_iterator/mat/hashsize 1        [            node:  mat_iterator/mat/hashtable[idx]            if (node)            [                mat_iterator/curidx: idx                return [mat_iterator/node: node]            ]        ]        return none;    ]];**************** matrix iterator: used for n-ari operations on dense arrays *********CV_MAX_ARR: 10CvNArrayIterator!: make struct! [    count				[integer!]		; number of arrays    dims				[integer!]      ; number of dimensions to iterate    ;size				[struct! (first CvSize!)]; maximal common linear size: { width = size, height = 1 }    width				[integer!]    height!				[integer!]    ptr					[struct![(first ptr!-ptr!)]]	;pointers to the array slices [CV_MAX_ARR]    stack				[integer!]		; for internal use [CV_MAX_DIM    hdr					[integer!]		;/* pointers to the headers of the CvMatND! matrices that are processed [CV_MAX_ARR]    									; may be we need a CvMatND! struct!  ] noneCV_NO_DEPTH_CHECK:     1CV_NO_CN_CHECK:        2CV_NO_SIZE_CHECK:      4;(the function together with cvNextArraySlice is used for N-ari element-wise operations)cvInitNArrayIterator: cvFunc  ["initializes iterator that traverses through several arrays simultaneously"	count			[integer!]	arrs			[ptr!]		;(first CvArr!)	mask			[ptr!]		;(first CvArr!)	stubs			[ptr!]      ;CvMatND!	array_iterator	[ptr!] 		;CvNArrayIterator	flags			[integer!]	return:			[integer!] ] core "cvInitNArrayIterator"cvNextNArraySlice: cvFunc  ["returns zero value if iteration is finished, non-zero (slice length) otherwise "	array_iterator	[ptr!]		;struct! (first CvNArrayIterator!)	return:			[integer!] ] core "cvNextNArraySlice" cvGetElemType: cvFunc  ["returns type of array elements: CV_8UC1 ... CV_64FC4 ..."	arr			[ptr!]       ;CvArr!	return:		[integer!]] core "cvGetElemType"cvGetDims: cvFunc  ["retrieves number of an array dimensions and optionally sizes of the dimensions"	arr			[ptr!]       ;CvArr!	sizes		[ptr!]		; CV_DEFAULT(NULL)	return:		[integer!]] core "cvGetDims"cvGetDimSize: cvFunc  [{Retrieves size of a particular array dimension.;For 2d arrays cvGetDimSize(arr,0) returns number of rows (image height) and cvGetDimSize(arr,1) returns number of columns (image width)}	arr			[ptr!]       ;CvArr!	index		[integer!]	;CV_DEFAULT(NULL)	return:		[integer!]] core "cvGetDimSize";ptr = &arr(idx0,idx1,...). All indexes are zero-based, the major dimensions go first (e.g. (y,x) for 2D, (z,y,x) for 3DcvPtr1D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	; 	type		[ptr!] 		; CV_DEFAULT(NULL)	return:		[ptr!] 		; or uchar*] core "cvPtr1D"cvPtr2D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	 	idx1		[integer!]	type		[ptr!] 		; CV_DEFAULT(NULL)	return:		[ptr!] 		; or uchar*] core "cvPtr2D"cvPtr3D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]; 	idx1		[integer!];	idx2		[integer!];	type		[ptr!] 		; CV_DEFAULT(NULL)	return:		[ptr!] ; or uchar*] core "cvPtr3D";For CvMat or IplImage number of indices should be 2;(row index (y) goes first, column index (x) goes next).;For CvMatND or CvSparseMat number of infices should match number of <dims> and;indices order should match the array dimension ordercvPtrND: cvFunc  [	arr					[ptr!]       ;CvArr!	idx					[ptr!]; 	type				[ptr!]		;CV_DEFAULT(NULL)	create_node			[integer!]	;CV_DEFAULT(1)	precalc_hashval		[ptr!]		; CV_DEFAULT(NULL)	return:				[ptr!] 		; or uchar*] core "cvPtrND"cvGet1D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]		return:		reduce [decimal! decimal! decimal! decimal!];CvScalar not a pointer] core "cvGet1D"cvGet2D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	idx1		[integer!];	return:		reduce [decimal! decimal! decimal! decimal!];CvScalar not a pointer] core "cvGet2D"cvGet3D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	idx1		[integer!];	idx2		[integer!];	return:		reduce [decimal! decimal! decimal! decimal!];CvScalar not a pointer		] core "cvGet3D"cvGetND: cvFunc  [	arr			[ptr!]       ;CvArr!	idx			[ptr!]	return:		reduce [decimal! decimal! decimal! decimal!];CvScalar not a pointer		] core "cvGetND";for 1-channel arrays cvGetReal1D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	return:		[decimal!]		] core "cvGetReal1D"cvGetReal2D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	idx1		[integer!]	return:		[decimal!]		] core "cvGetReal2D"cvGetReal3D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	idx1		[integer!]	idx2		[integer!]	return:		[decimal!]	] core "cvGetReal3D"cvGetRealND: cvFunc  [	arr			[ptr!]       ;CvArr!	idx			[ptr!]	return:		[decimal!]			] core "cvGetRealND";arr(idx0,idx1,...) = valuecvSet1D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	v0			[decimal!] ;CvScalar not pointer	v1			[decimal!]	v2			[decimal!]	v3			[decimal!]] core "cvSet1D"cvSet2D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	idx1		[integer!]	v0			[decimal!] ;CvScalar not pointer	v1			[decimal!]	v2			[decimal!]	v3			[decimal!]] core "cvSet2D"cvSet3D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	idx1		[integer!]	idx2		[integer!]	v0			[decimal!] ;CvScalar not pointer	v1			[decimal!]	v2			[decimal!]	v3			[decimal!]] core "cvSet3D"cvSetND: cvFunc  [	arr			[ptr!]       ;CvArr!	idx 		[ptr!]	v0			[decimal!] ;CvScalar not pointer	v1			[decimal!]	v2			[decimal!]	v3			[decimal!]] core "cvSetND";for 1-channel arrayscvSetReal1D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	value		[decimal!]] core "cvSetReal1D"cvSetReal2D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	idx1		[integer!]	value		[decimal!]] core "cvSetReal2D"cvSetReal3D: cvFunc  [	arr			[ptr!]       ;CvArr!	idx0		[integer!]	idx1		[integer!]	idx2		[integer!]	value		[decimal!]] core "cvSetReal3D"cvSetRealND: cvFunc  [	arr			[ptr!]       ;CvArr!	idx 		[ptr!]	value		[decimal!]] core "cvSetRealND"cvClearND: cvFunc  ["clears element of ND dense array, in case of sparse arrays it deletes the specified node"	arr			[ptr!]	idx 		[ptr!]] core "cvClearND"{Converts CvArr (IplImage or CvMat,...) to CvMat.If the last parameter is non-zero, function canconvert multi(>2)-dimensional array to CvMat as long asthe last array's dimension is continous. The resultantmatrix will be have appropriate (a huge) number of rows}cvGetMat: cvFunc  ["Converts CvArr (IplImage or CvMat,...) to CvMat"	arr			[ptr!]       				;CvArr!	header		[ptr!] 						; CvMat!	coi			[ptr!]						;CV_DEFAULT(NULL)	allowND		[integer!]					;CV_DEFAULT(0)	return: 	[ptr!]]core "cvGetMat"cvGetImage: cvFunc  ["Converts CvArr (IplImage or CvMat) to IplImage"	arr				[ptr!]       ;CvArr!    image_header 	[ptr!] 		; IplImage!	return: 		[ptr!]	] core "cvGetImage"{Changes a shape of multi-dimensional array.new_cn == 0 means that number of channels remains unchanged.new_dims == 0 means that number and sizes of dimensions remain the same(unless they need to be changed to set the new number of channels)if new_dims == 1, there is no need to specify new dimension sizesThe resultant configuration should be achievable w/o data copying.If the resultant array is sparse, CvSparseMat header should be passedto the function else if the result is 1 or 2 dimensional,CvMat header should be passed to the functionelse CvMatND header should be passed}cvReshapeMatND: cvFunc  ["Changes a shape of multi-dimensional array" 	arr				[ptr!]       ;CvArr!	sizeof_header	[integer!]	header			[ptr!]       ;CvArr!	new_cn			[integer!]	new_dims		[integer!]	new_sizes		[ptr!]	return: 		[ptr!]]core "cvReshapeMatND"cvReshapeND: func [arr header new_cn new_dims new_sizes][ cvReshapeMatND arr size? header header new_cn new_dims new_sizes]cvReshape: cvFunc  [	arr				[ptr!]       ;CvArr!	header			[ptr!]       ;CvArr!	new_cn			[integer!]	new_rows		[integer!]	;CV_DEFAULT(0)	return: 		[ptr!]] core "cvReshape"cvRepeat: cvFunc  ["Repeats source 2d array several times in both horizontal and vertical direction to fill destination array"	src				[ptr!]       ;CvArr!	dst				[ptr!]       ;CvArr!] core "cvRepeat" cvCreateData: cvFunc  ["allocates array data"	arr				[ptr!]       ;CvArr!] core "cvCreateData"cvReleaseData: cvFunc  ["releases array data"	arr				[ptr!] ; double pointer] core "cvReleaseData"cvSetData: cvFunc  [{Attaches user data to the array header. The step is reffered tothe pre-last dimension. That is, all the planes of the arraymust be joint (w/o gaps)}	arr				[ptr!]       ;CvArr!	data			[ptr!]		;void* pointer 	step			[integer!]] core "cvSetData"{Retrieves raw data of CvMat, IplImage or CvMatND.In the latter case the function raises an error ifthe array can not be represented as a matrix}cvGetRawData: cvFunc  ["retrieves raw data of CvMat, IplImage or CvMatND"	arr				[ptr!]      ;CvArr!	data			[ptr!] ;uchar** pointer	step			[ptr!]; CV_DEFAULT(NULL)	roi_size		[ptr!]; CvSize: CV_DEFAULT(NULL)] core "cvGetRawData";openCVcvGetSize_: cvFunc  ["Returns width and height of array in elements"	arr				[ptr!] ; CvArr!"IplImage or Matrice"	return: 		[long]; CvSize not a pointer] core "cvGetSize"; IplImage! or CvMat!cvGetSize: func [arr [integer!] ] [	img: getIPLImage arr	either CV_IS_IMAGE arr [reduce [img/width img/height]] [reduce [img/cols img/rows]]]  cvCopy: cvFunc  ["copies source array to destination array"	src				[ptr!] 	;CvArr!	dst				[ptr!] 	;CvArr!	mask			[ptr!]; CV_DEFAULT(NULL) or none in REBOL] core "cvCopy"cvSet: cvFunc  ["sets all or masked elements of input array to the same value"	arr				[ptr!]	v0				[decimal!]; CvScalar not a pointer    v1				[decimal!]    v2				[decimal!]    v3				[decimal!]	mask			[ptr!] ; CV_DEFAULT(NULL) ] core "cvSet"cvSetZero: cvFunc  ["clears all the array elements (sets them to 0)"	arr				[ptr!]       ;CvArr!] core "cvSetZero"cvZero: cvFunc  ["alias cvSetZero cvZero"	arr				[ptr!]; CvArr!] core "cvSetZero"; Split and merge require ream ptr! address :); use &pointercvSplit: cvFunc  ["splits a multi-channel array into the set of single-channel arrays or extracts particular [color] plane"	src				[ptr!] ;source 	dst0			[ptr!] 	dst1			[ptr!] 		dst2			[ptr!] 	dst3			[ptr!] ] core "cvSplit"cvMerge: cvFunc  [{merges a set of single-channel arrays into the single multi-channel array or inserts one particular [color] plane to the array}	src0			[ptr!] 	src1			[ptr!]  	src2			[ptr!] 	src3			[ptr!] 	dst				[ptr!] ; destination array] core "cvMerge"cvMixChannels: cvFunc  ["copies several channels from input arrays to certain channels of output arrays"	src			[ptr!]			;CvArr!	src_count	[integer!]	dst			[ptr!]			;CvArr!	dst_count	[integer!]	from_to		[ptr!]			;CvArr!	pair_count 	[integer!]	]core "cvMixChannels"{Performs linear transformation on every source array element:dst(x,y,c) = scale*src(x,y,c)+shift.Arbitrary combination of input and output array depths are allowed(number of channels must be the same), thus the function can be usedfor type conversion}cvConvertScale: cvFunc  ["performs linear transformation on every source array element"	src			[ptr!] ; CvArr!	dst			[ptr!] ; CvArr!	scale		[decimal!]					;CV_DEFAULT(1)	shift		[decimal!]					;CV_DEFAULT(0)] core "cvConvertScale"cvScale: func [src dst scale shift][	cvConvertScale src dst scale shift]cvCvtScale: func [src dst scale shift][	cvConvertScale src dst scale shift]cvConvert: func [src dst] [cvConvertScale src dst 1.0 0.0]{Performs linear transformation on every source array element,stores absolute value of the result:dst(x,y,c) = abs(scale*src(x,y,c)+shift).destination array must have 8u type.In other cases one may use cvConvertScale + cvAbsDiffS}cvConvertScaleAbs: cvFunc  ["performs linear transformation on every source array element"	src			[ptr!] ; CvArr!	dst			[ptr!] ; CvArr!	scale		[decimal!]				;CV_DEFAULT(1)	shift		[decimal!]				;CV_DEFAULT(0)] core "cvConvertScaleAbs"cvCvtScaleAbs: func [src dst scale shift] [	cvConvertScaleAbs src dst scale shift];checks termination criteria validity and sets eps to default_eps (if it is not set),;max_iter to default_max_iters (if it is not set)cvCheckTermCriteria: cvFunc  ["checks termination criteria validity and sets eps to default_eps (if it is not set)"	criteria			[ptr!]		;[struct! (first CvTermCriteria!)]	default_eps			[decimal!]	default_max_iters 	[integer!]	return: 			[ptr!]		;CvTermCriteria!	] core "cvCheckTermCriteria";****************************************************************************************\;*                   Arithmetic, logic and comparison operations                          *;****************************************************************************************/;pb with scalar in rebol;dst(mask) = src1(mask) + src2(mask);; all these routines want integer pointer ;All the arrays must have the same type, except the mask, and the same size (or ROI size)cvAdd: cvFunc  [	src1			[ptr!] ; CvArr!;CvArr!	src2			[ptr!] ; CvArr! 	dst				[ptr!] ; CvArr! 	mask			[ptr!] ;CvArr!;CV_DEFAULT(NULL) 0]core "cvAdd";dst(mask) = src(mask) + valuecvAddS: cvFunc  [	src				[ptr!] 		; CvArr! 	v0              [decimal!]  ;cvScalar 4 values      v1              [decimal!]    v2              [decimal!]    v3              [decimal!]	dst				[ptr!];[struct! (first CvArr!)] ;CvArr!	mask			[ptr!] ;CvArr! CV_DEFAULT(NULL) 	]core "cvAddS";dst(mask) = src1(mask) - src2(mask) */cvSub: cvFunc  [	src1			[ptr!] ; CvArr! 	src2			[ptr!] ; CvArr! 	dst				[ptr!] ; CvArr! 	mask			[ptr!] ;CvArr!;CV_DEFAULT(NULL)]core "cvSub"; dst(mask) = src(mask) - value = src(mask) + (-value) ; CV_INLINE  void  cvSubS( const CvArr! src, CvScalar value, CvArr! dst, const CvArr! mask CV_DEFAULT(NULL))cvSubS: func [src  v0 v1 v2 v3  dst  mask /local cvalue]  [    cvalue: make struct! CvScalar! none    cvalue/v0: negate v0    cvalue/v1: negate v1    cvalue/v2: negate v2    cvalue/v3: negate v3    cvAddS src cvalue/v0 cvalue/v1 cvalue/v2 cvalue/v3 dst mask    ];dst(mask) = value - src(mask)cvSubRS: cvFunc  [	src				[ptr!] ;CvArr!	v0              [decimal!]        v1              [decimal!]    v2              [decimal!]    v3              [decimal!]	dst				[ptr!] ;CvArr!	mask			[ptr!] ;CvArr! CV_DEFAULT(NULL)]core "cvSubRS";dst(idx) = src1(idx) * src2(idx) * scale (scaled element-wise multiplication of 2 arrays)cvMul: cvFunc  [	src1				[ptr!] ; CvArr! 	src2				[ptr!] ; CvArr! 	dst 				[ptr!] ; CvArr! 	scale				[decimal!] ;CV_DEFAULT(1))] core "cvMul"{element-wise division/inversion with scaling: dst(idx) = src1(idx) * scale / src2(idx)or dst(idx) = scale / src2(idx) if src1 == 0}    cvDiv: cvFunc  [	src1				[ptr!] ;CvArr!	src2				[ptr!] ; CvArr!	dst 				[ptr!] ; CvArr!	scale				[decimal!] ;CV_DEFAULT(1))] core "cvDiv";dst = src1 * scale + src2 */cvScaleAdd: cvFunc  [	src1				[ptr!] ;CvArr!	v0              	[decimal!]        v1              	[decimal!]    v2              	[decimal!]    v3              	[decimal!]	src2				[ptr!] ;CvArr!	dst 				[ptr!] ;CvArr!]core "cvScaleAdd"cvAXPY: func [A real_scalar B C] [cvScaleAdd A real_scalar B C]; dst = src1 * alpha + src2 * beta + gammacvAddWeighted: cvFunc  [	src1				[ptr!] ;CvArr!	alpha				[decimal!]	src2				[ptr!] ;CvArr!	beta				[decimal!]	gamma				[decimal!]	dst					[ptr!] ;CvArr!] core "cvAddWeighted";result = sum_i(src1(i) * src2(i)) (results for all channels are accumulated together)cvDotProduct: cvFunc  [	src1				[ptr!] ; CvArr! 	src2				[ptr!] ; CvArr! 	return:				[decimal!]] core "cvDotProduct";dst(idx) = src1(idx) & src2(idx)cvAnd: cvFunc  [	src1				[ptr!] ; CvArr! 	src2				[ptr!] ; CvArr! 	dst 				[ptr!] ; CvArr! 	mask				[ptr!] ;CvArr! CV_DEFAULT(NULL)] core "cvAnd" ;dst(idx) = src(idx) & value */cvAndS: cvFunc  [	src					[ptr!] ;CvArr!	;value				[ptr!]	v0              	[decimal!]        v1              	[decimal!]    v2              	[decimal!]    v3              	[decimal!]	dst 				[ptr!] ;CvArr!	mask				[ptr!] ;CvArr!;CV_DEFAULT(NULL)] core "cvAndS" ;dst(idx) = src1(idx) | src2(idx)cvOr: cvFunc  [	src1				[ptr!] ; CvArr! 	src2				[ptr!] ; CvArr! 	dst 				[ptr!] ; CvArr! 	mask				[ptr!] ;CvArr! ;CV_DEFAULT(NULL)] core "cvOr" ;dst(idx) = src(idx) | valuecvOrS: cvFunc  [	src					[ptr!] ;CvArr!	;value				[ptr!]	v0              	[decimal!]        v1              	[decimal!]    v2              	[decimal!]    v3              	[decimal!]	dst 				[ptr!] ;CvArr!	mask				[ptr!] ;CvArr!;CV_DEFAULT(NULL)] core "cvOrS" ;dst(idx) = src1(idx) ^ src2(idx)cvXor: cvFunc  [	src1				[ptr!] ; CvArr! 	src2				[ptr!] ; CvArr! 	dst 				[ptr!] ; CvArr! 	mask				[ptr!] ;CvArr!;CV_DEFAULT(NULL)] core "cvXor" ;dst(idx) = src(idx) ^ valuecvXorS: cvFunc  [	src					[ptr!] ;CvArr!	v0              	[decimal!]        v1              	[decimal!]    v2              	[decimal!]    v3              	[decimal!]	dst 				[ptr!] ;CvArr!	mask				[ptr!] ;CvArr!;CV_DEFAULT(NULL)] core "cvXorS" ;/* dst(idx) = ~src(idx)cvNot: cvFunc  [	src					[ptr!] ; CvArr! 	dst					[ptr!] ; CvArr! ] core "cvNot";dst(idx) = lower(idx) <= src(idx) < upper(idx) */cvInRange: cvFunc  [	src					[ptr!] ; CvArr! 	lower               [ptr!] ; CvArr!    upper               [ptr!] ; CvArr!	dst					[ptr!] ; CvArr!] core "cvInRange";dst(idx) = lower <= src(idx) < upper */cvInRangeS: cvFunc  [	src					[ptr!] ; CvArr! 	;lower              [_CvScalar]    lower_v0            [decimal!]        lower_v1            [decimal!]	lower_v2            [decimal!]    lower_v3            [decimal!]    ;upper              [_CvScalar]    upper_v0            [decimal!]        upper_v1            [decimal!]    upper_v2            [decimal!]    upper_v3            [decimal!]	dst					[ptr!]; [struct! (first CvArr!)] ] core "cvInRangeS"; comparaison operators  CV_CMP_EQ:   0 CV_CMP_GT:   1 CV_CMP_GE:   2 CV_CMP_LT:   3 CV_CMP_LE:   4 CV_CMP_NE:   5  ;dst(idx) = src1(idx) _cmp_op_ src2(idx) */ cvCmp: cvFunc  [ "The comparison operation support single-channel arrays only. Destination image should be 8uC1 or 8sC1"	src1				[ptr!] ; CvArr! 	src2				[ptr!] ; CvArr! 	dst					[ptr!] ; CvArr! 	cmp_op				[integer!] ] core "cvCmp"  cvCmpS: cvFunc  [ "dst(idx) = src1(idx) _cmp_op_ value"	src					[ptr!] ; CvArr!	value				[decimal!]	dst					[ptr!] ; CvArr!	cmp_op				[integer!] ] core "cvCmpS"cvMin: cvFunc  ["dst(idx) = min(src1(idx),src2(idx)"	src1				[ptr!] ; CvArr! 	src2				[ptr!] ; CvArr! 	dst					[ptr!] ; CvArr!  ] core "cvMin"cvMax: cvFunc  [";dst(idx) = max(src1(idx),src2(idx))"	src1				[ptr!] ; CvArr! 	src2				[ptr!] ; CvArr! 	dst					[ptr!] ; CvArr!  ] core "cvMax" cvMinS: cvFunc  [ "dst(idx) = min(src(idx),value)"	src					[ptr!] ; CvArr! 	value				[decimal!]	dst					[ptr!] ; CvArr!  ] core "cvMinS"cvMaxS: cvFunc  ["dst(idx) = max(src(idx),value)"	src					[ptr!] ; CvArr! 	value				[decimal!]	dst					[ptr!] ; CvArr!  ] core "cvMaxS"  cvAbsDiff: cvFunc  [ " dst(x,y,c) = abs(src1(x,y,c) - src2(x,y,c))"	src1				[ptr!] ; CvArr! 	src2				[ptr!] ; CvArr! 	dst					[ptr!] ; CvArr!  ] core "cvAbsDiff"  cvAbsDiffS: cvFunc  [ "dst(x,y,c) = abs(src(x,y,c) - value(c))"	src				    [ptr!] ; CvArr! 	dst					[ptr!] ; CvArr! 	v0              	[decimal!] ;CvScalar!    v1              	[decimal!]    v2              	[decimal!]    v3              	[decimal!]	 ] core "cvAbsDiffS"  cvAbs: func [src dst] [v: cvScalarAll 0 cvAbsDiffS src dst v/v0 v/v1 v/v2 v/v3];/****************************************************************************************\;*                                Math operations                                         *;\**************************************************************************************** cvCartToPolar: cvFunc  [ "Does cartesian->polar coordinates conversion. Either of output components (magnitude or angle) is optional"	x						[ptr!]	y						[ptr!]	magnitude				[ptr!]	angle					[ptr!]; CV_DEFAULT(NULL)	angle_in_degrees		[integer!]; CV_DEFAULT(0) ] core "cvCartToPolar"  cvPolarToCart: cvFunc  [{Does polar->cartesian coordinates conversion.Either of output components (magnitude or angle) is optional.If magnitude is missing it is assumed to be all 1's }	magnitude				[ptr!]	angle					[ptr!]; CV_DEFAULT(NULL)	x						[ptr!]	y						[ptr!]	angle_in_degrees		[integer!]; CV_DEFAULT(0) ] core "cvPolarToCart"  cvPow: cvFunc  ["Does powering: dst(idx) = src(idx)^power"	src				[ptr!] ; CvArr!	dst				[ptr!] ; CvArr!	power			[decimal!]] core "cvPow"cvExp: cvFunc  [{Does exponention: dst(idx) = exp(src(idx)).Overflow is not handled yet. Underflow is handled.Maximal relative error is ~7e-6 for single-precision input}	src				[ptr!] ; CvArr!	dst				[ptr!] ; CvArr!] core "cvExp"cvLog: cvFunc  [{Calculates natural logarithms: dst(idx) = log(abs(src(idx))).Logarithm of 0 gives large negative number(~-700)Maximal relative error is ~3e-7 for single-precision output}	src				[ptr!] ; CvArr!	dst				[ptr!] ; CvArr!] core "cvLog"cvFastArctan: cvFunc ["Fast arctangent calculation" 	y		[decimal!]	x		[decimal!]	return: [decimal!]] core "cvFastArctan"cvCbrt: cvFunc ["Fast cubic root calculation"	value	[decimal!]	return: [decimal!]] core "cvCbrt" {Checks array values for NaNs, Infs or simply for too large numbers   (if CV_CHECK_RANGE is set). If CV_CHECK_QUIET is set,   no runtime errors is raised (function returns zero value in case of "bad" values).   Otherwise cvError is called}   CV_CHECK_RANGE:    1CV_CHECK_QUIET:    2cvCheckArr: cvFunc  ["Checks array values for NaNs, Infs or simply for too large numbers"	arr				[ptr!] ; CvArr!	flags			[integer!] ;CV_DEFAULT(0)	min_val 		[decimal!]; CV_DEFAULT(0) 	max_val 		[decimal!];CV_DEFAULT(0))	return: 		[integer!]	] core "cvCheckArr"	   alias 'cvCheckArr "cvCheckArray"CV_RAND_UNI:      0CV_RAND_NORMAL:   1cvRandArr: cvFunc  [	rng			   	[ptr!] ; pointer to CvRNG funct	arr				[ptr!] ; CvArr!	dist_type		[integer!] ; CV_RAND_UNI or CV_RAND_NORMAL 	;param1			[_CvScalar]    param1_v0       [decimal!]        param1_v1       [decimal!]    param1_v2       [decimal!]    param1_v3       [decimal!]    ;param2			[_CvScalar]    param2_v0       [decimal!]        param2_v1       [decimal!]    param2_v2       [decimal!]    param2_v3       [decimal!]	] core "cvRandArr"cvRandShuffle: cvFunc  [	mat				[ptr!] ; CvArr!			rng				[ptr!] ; pointer to CvRNG funct	iter_factor		[decimal!]; CV_DEFAULT(1.0)] core "cvRandShuffle"CV_SORT_EVERY_ROW:		 0CV_SORT_EVERY_COLUMN:	 1CV_SORT_ASCENDING:		 0CV_SORT_DESCENDING:		 16; only for single channel array for src and dst;cvSort: make cvFunc  [	src				[ptr!] ; CvArr!	dst				[ptr!] ; CV_DEFAULT(NULL)	idxmat			[ptr!] ; CV_DEFAULT(NULL)	flags			[integer!]				 ; CV_DEFAULT(0))	] core "cvSort"cvSolveCubic: cvFunc  ["Finds real roots of a cubic equation"	coeffs			[ptr!] ; CvMat!	roots			[ptr!] ; CvMat!	return: 		[integer!]] core "cvSolveCubic"cvSolvePoly: cvFunc  ["Finds all real and complex roots of a polynomial equation"	coeffs			[ptr!] ; CvMat!	roots2			[ptr!] ; CvMat!	maxiter			[integer!]; CV_DEFAULT(20)	fig				[integer!]; CV_DEFAULT(100)] core "cvSolvePoly";/****************************************************************************************\;*                                Matrix operations                                       *;\****************************************************************************************/cvCrossProduct: cvFunc  ["Calculates cross product of two 3d vectors"	src1			[ptr!] ; CvArr!	src2			[ptr!] ; CvArr!	dst				[ptr!] ; CvArr!] core "cvCrossProduct"cvGEMM: cvFunc  ["Extended matrix transform: dst = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X^T"	src1			[ptr!] ; CvArr!	src2			[ptr!] ; CvArr!	alpha			[decimal!]	src3			[ptr!] ; CvArr!	beta			[decimal!]	dst				[ptr!] ; CvArr!	tABC			[integer!];CV_DEFAULT(0)	] core "cvGEMM"alias 'cvGEMM "vMatMulAddEx";Matrix transform: dst = A*B + C, C is optional cvMatMulAdd: func [src1 src2 src3 dst][cvGEMM src1 src2 1.0 src3 1.0 dst 0 ]cvMatMul: func [src1 src2 dst] [cvMatMulAdd src1 src2 none dst]CV_GEMM_A_T: 1CV_GEMM_B_T: 2CV_GEMM_C_T: 4cvTransform: cvFunc  ["transforms each element of source array and stores resultant vectors in destination array"	src			[ptr!] ; CvArr!	dst			[ptr!] ; CvArr!	transmat	[ptr!] ; CvMat!	shiftvec	[ptr!]] core "cvTransform"alias 'cvTransform "cvMatMulAddS"cvPerspectiveTransform: cvFunc  ["Does perspective transform on every element of input array "	src			[ptr!] ; CvArr!	dst			[ptr!] ; CvArr!	mat			[ptr!] ; CvMat!] core "cvPerspectiveTransform"cvMulTransposed: cvFunc  ["Calculates (A-delta)*(A-delta)^T (order=0) or (A-delta)^T*(A-delta) (order=1)"	src			[ptr!] ; CvArr!	dst			[ptr!] ; CvArr!	order		[integer!]	delta		[ptr!] ;CV_DEFAULT(NULL)	scale		[decimal!];CV_DEFAULT(1.)] core "cvMulTransposed"cvTranspose: cvFunc  ["Tranposes matrix. Square matrices can be transposed in-place"	src			[ptr!] ; CvArr!	dst			[ptr!] ; CvArr!] core "cvTranspose"alias 'cvTranspose "cvT"cvCompleteSymm: cvFunc  ["Completes the symmetric matrix from the lower (LtoR=0) or from the upper (LtoR!=0) part"	matrix 	[ptr!] ; CvMat!	LtoR 		[integer!] ; CV_DEFAULT(0) )] core "cvCompleteSymm"cvFlip: cvFunc  [{Mirror array data around horizontal (flip=0),vertical (flip=1) or both(flip=-1) axises:cvFlip(src) flips images vertically and sequences horizontally (inplace)}	src			[ptr!] ; CvArr!	dst			[ptr!] ; CvArr! ;CV_DEFAULT(src)	flip_mode	[integer!]] core "cvFlip"alias 'cvFlip "cvMirror"CV_SVD_MODIFY_A:   1CV_SVD_U_T:        2CV_SVD_V_T:        4cvSVD: cvFunc  ["Performs Singular Value Decomposition of a matrix"	A			[ptr!] ; CvArr!	W			[ptr!] ; CvArr!	U			[ptr!] ;DEFAULT(NULL)	V			[ptr!] ;DEFAULT(NULL)	flags		[integer!]] core "cvSVD"cvSVBkSb: cvFunc  ["Performs Singular Value Back Substitution (solves A*X = B): flags must be the same as in cvSVD"	W			[ptr!] ; CvArr!	U			[ptr!] ; CvArr!	V			[ptr!] ; CvArr!	B			[ptr!] ; CvArr!	flags		[integer!]] core "cvSVBkSb"CV_LU:  0CV_SVD: 1CV_SVD_SYM: 2cvInvert: cvFunc  ["Inverts matrix  (CV_32F OR CV_64F images!)"	src			[ptr!] ; CvArr!	dst			[ptr!] ; CvArr!	method		[integer!]	return: 	[decimal!];CV_DEFAULT(CV_LU)] core "cvInvert"alias 'cvInvert "cvInv"cvSolve: cvFunc  ["Solves linear system (src1)*(dst) = (src2) (returns 0 if src1 is a singular and CV_LU method is used)"	src1		[ptr!] ; CvArr!	src2		[ptr!] ; CvArr!	dst			[ptr!] ; CvArr!	method		[integer!];CV_DEFAULT(CV_LU)	return: 	[integer!]] core "cvSolve"cvDet: cvFunc  ["Calculates determinant of input matrix"	mat			[ptr!] ; CvArr!	return: 	[decimal!]] core "cvDet"cvTrace: cvFunc  ["Calculates trace of the matrix (sum of elements on the main diagonal)"	mat			[ptr!] ; CvArr!	return: 	reduce [decimal! decimal! decimal! decimal!] ; CvScalar] core "cvTrace"cvEigenVV: cvFunc  ["Finds eigen values and vectors of a symmetric matrix"	mat			[ptr!] ; CvArr!	evects		[ptr!] ; CvArr!	evals		[ptr!] ; CvArr!	eps			[decimal!];CV_DEFAULT(0)	lowindex	[integer!]; CV_DEFAULT(-1)	highindex	[integer!]; CV_DEFAULT(-1))	] core "cvEigenVV"cvSetIdentity: cvFunc  ["Makes an identity matrix (mat_ij = i == j)"	mat					[ptr!] ; CvArr!	v0              	[decimal!] ;CvScalar ;CV_DEFAULT(cvRealScalar 1    v1              	[decimal!]    v2              	[decimal!]    v3              	[decimal!] ] core "cvSetIdentity"cvRange: cvFunc  ["Fills matrix with given range of numbers"	mat			[ptr!] ; CvMat!	start		[decimal!]	end			[decimal!]] core "cvRange"; Calculates covariation matrix for a set of vectors transpose([v1-avg, v2-avg,...]) * [v1-avg,v2-avg,...]  CV_COVAR_SCRAMBLED: 0; [v1-avg, v2-avg,...] * transpose([v1-avg,v2-avg,...])  CV_COVAR_NORMAL:    1; do not calc average (i.e. mean vector) - use the input vector instead (useful for calculating covariance matrix by parts)  CV_COVAR_USE_AVG:   2; scale the covariance matrix coefficients by number of the vectors  CV_COVAR_SCALE:     4; all the input vectors are stored in a single matrix, as its rows  CV_COVAR_ROWS:      8; all the input vectors are stored in a single matrix, as its columns  CV_COVAR_COLS:     16cvCalcCovarMatrix: cvFunc  [	vects		[ptr!] ; CvArr! ;CvArr**	count		[integer!]	cov_mat		[ptr!] ; CvArr!	avg			[ptr!] ; CvArr!	flags		[integer!]] core "cvCalcCovarMatrix"CV_PCA_DATA_AS_ROW: 	0 CV_PCA_DATA_AS_COL: 	1CV_PCA_USE_AVG:		 	2cvCalcPCA: cvFunc  [	data		[ptr!] ; CvArr!	mean		[ptr!] ; CvArr!	eigenvals	[ptr!] ; CvArr!	eigenvects	[ptr!] ; CvArr!	flags		[integer!]] core "cvCalcPCA" cvProjectPCA: cvFunc  [	data		[ptr!] ; CvArr!	mean		[ptr!] ; CvArr!	eigenvects	[ptr!] ; CvArr!	result		[ptr!] ; CvArr!] core "cvProjectPCA"cvBackProjectPCA: cvFunc  [	proj		[ptr!] ; CvArr!	mean		[ptr!] ; CvArr!	eigenvects	[ptr!] ; CvArr!	result		[ptr!] ; CvArr!] core "cvBackProjectPCA"cvMahalanobis: cvFunc  ["Calculates Mahalanobis(weighted) distance"	vec1		[ptr!] ; CvArr!	vec2		[ptr!] ; CvArr!	mat			[ptr!] ; CvArr!	return: 	[decimal!]] core "cvMahalanobis"alias 'cvMahalanobis "cvMahalonobis";/****************************************************************************************\;*                                    Array Statistics                                    *;\****************************************************************************************/cvSum: cvFunc  ["Finds sum of array elements "	arr		[ptr!] ; CvArr!	return:	[ptr!] ;CvScalar] core "cvSum"cvCountNonZero: cvFunc  ["Calculates number of non-zero pixels. The array, must be single-channel array or multi-channel image with COI set. "	arr		[ptr!] ; CvArr!	return:	[integer!]] core "cvCountNonZero"cvAvg: cvFunc  ["Calculates mean value of array elements"	arr		[ptr!] ; CvArr!	mask	[ptr!] ; CvArr!;CV_DEFAULT(NULL)	return:	[decimal!] ;CvScalar] core "cvAvg"cvAvgSdv: cvFunc  ["Calculates mean and standard deviation of pixel values"	arr		[ptr!] ; CvArr!	mean	[ptr!]	std_dev [ptr!]	mask	[ptr!];CV_DEFAULT(NULL)] core "cvAvgSdv"cvMinMaxLoc: cvFunc  ["Finds global minimum, maximum and their positions"	arr			[ptr!]       ;CvArr!	min_val		[ptr!] ; pointer to [decimal!]	max_val		[ptr!] ;[decimal!]	min_loc		[ptr!];CvPoint: CV_DEFAULT(NULL)	max_loc		[ptr!];CvPoint: CV_DEFAULT(NULL)	mask	 	[ptr!] ;[struct! (first CvArr!)];CV_DEFAULT(NULL)] core "cvMinMaxLoc";types of array norm  CV_C:            1 CV_L1:           2 CV_L2:           4 CV_NORM_MASK:    7 CV_RELATIVE:     8 CV_DIFF:         16 CV_MINMAX:       32 CV_DIFF_C:       CV_DIFF OR CV_C CV_DIFF_L1:      CV_DIFF OR CV_L1 CV_DIFF_L2:      CV_DIFF OR CV_L2 CV_RELATIVE_C:   CV_RELATIVE OR CV_C CV_RELATIVE_L1:  CV_RELATIVE OR CV_L1 CV_RELATIVE_L2:  CV_RELATIVE OR CV_L2  cvNorm: cvFunc  [ "Finds norm, difference norm or relative difference norm for an array (or two arrays)"	arr1			[ptr!] ; CvArr!	arr2			[ptr!] ; CvArr!;CV_DEFAULT(NULL)	norm_type 		[integer!]; CV_DEFAULT(CV_L2)	mask	 		[ptr!] ; CvArr!;CV_DEFAULT(NULL)	return:			[decimal!] ]core "cvNorm" cvNormalize: cvFunc  [	src			[ptr!] ; CvArr!	dst			[ptr!] ; CvArr!	a			[decimal!];CV_DEFAULT(1.)	b			[decimal!];CV_DEFAULT(0.)	norm_type	[integer!];CV_DEFAULT(CV_L2)	mask	 	[ptr!] ; CvArr!;CV_DEFAULT(NULL)] core "cvNormalize" CV_REDUCE_SUM: 0CV_REDUCE_AVG: 1CV_REDUCE_MAX: 2CV_REDUCE_MIN: 3cvReduce: cvFunc  [	src			[ptr!] ; CvArr!	dst			[ptr!] ; CvArr!	dim 		[integer!];CV_DEFAULT(-1)	op 			[integer!];CV_DEFAULT(CV_REDUCE_SUM) )] core "cvReduce";/****************************************************************************************\;*                      Discrete Linear Transforms and Related Functions                  *;\****************************************************************************************/ CV_DXT_FORWARD:  0 CV_DXT_INVERSE:  1 CV_DXT_SCALE:    2 ;divide result by size of array  CV_DXT_INV_SCALE: CV_DXT_INVERSE + CV_DXT_SCALE CV_DXT_INVERSE_SCALE: CV_DXT_INV_SCALE CV_DXT_ROWS:     4 ;transform each row individually  CV_DXT_MUL_CONJ: 8 ;conjugate the second argument of cvMulSpectrums   cvDFT: cvFunc  [ "Discrete Fourier Transform: complex->complex,real->ccs (forward),ccs->real (inverse)"	src				[ptr!] ; CvArr!	dst				[ptr!] ; CvArr!	flags			[integer!]	nonzero_rows 	[integer!];CV_DEFAULT(0)	return:			[]] core "cvDFT"alias 'cvDFT "cvFFT"cvMulSpectrums: cvFunc  ["Multiply results of DFTs: DFT(X)*DFT(Y) or DFT(X)*conj(DFT(Y))"	src1			[ptr!] ; CvArr!	src2			[ptr!] ; CvArr!	dst				[ptr!] ; CvArr!	flags			[integer!]	return:			[]] core "cvMulSpectrums"cvGetOptimalDFTSize: cvFunc ["Finds optimal DFT vector size >= size0"	size0		[integer!]	return:		[integer!]] core "cvGetOptimalDFTSize"cvDCT: cvFunc  ["Discrete Cosine Transform"	src				[ptr!] ; CvArr!	dst				[ptr!] ; CvArr!	flags			[integer!]] core "cvDCT";/****************************************************************************************\;*                              Dynamic data structures                                   *;\****************************************************************************************/cvSliceLength: cvFunc  ["Calculates length of sequence slice (with support of negative indices)"	slice_start_index       [integer!] ;CvSlice     slice_end_index         [integer!]	seq						[ptr!] ; CvSeq as pointer	return:					[integer!]] core "cvSliceLength";PAUSEcvCreateMemStorage: cvFunc  ["Creates new memory storage. block_size = 0 means that default,somewhat optimal size, is used (currently, it is 64K)"	block_size 		[integer!]	;CV_DEFAULT(0)	return:			[ptr!]		; pointer to CvMemStorage] core "cvCreateMemStorage";Creates a memory storage that will borrow memory blocks from parent storagecvCreateChildMemStorage: cvFunc  [	parent	 		[ptr!]		; pointer to CvMemStorage	return:			[ptr!]		; pointer to CvMemStorage] core "cvCreateChildMemStorage";Releases memory storage. All the children of a parent must be released before the parent. ;A child storage returns all the blocks to parent when it is released;OPENVCVcvReleaseMemStorage: cvFunc  [	storage	 		[ptr!] ;CvMemStorage** (address?)] core "cvReleaseMemStorage"{Clears memory storage. This is the only way(!!!) (besides cvRestoreMemStoragePos)to reuse memory allocated for the storage - cvClearSeq,cvClearSet ...do not free any memory.A child storage returns all the blocks to the parent when it is cleared}cvClearMemStorage: cvFunc  [	storage	 		[ptr!]		; pointer to CvMemStorage] core "cvClearMemStorage";Remember a storage "free memory" position cvSaveMemStoragePos: cvFunc  [	storage	 		[ptr!]		; pointer to CvMemStorage	pos		 		[ptr!]		; pointer to CvMemStorage] core "cvSaveMemStoragePos";Restore a storage "free memory" positioncvRestoreMemStoragePos: cvFunc  [	storage	 		[ptr!]		; pointer to CvMemStorage	pos		 		[ptr!]		; pointer to CvMemStorage] core "cvRestoreMemStoragePos";Allocates continuous buffer of the specified size in the storage */cvMemStorageAlloc: cvFunc  [	storage	 		[ptr!]		; pointer to CvMemStorage	size_t		 	[integer!] ] core "cvMemStorageAlloc";Allocates string in memory storage */cvMemStorageAllocString: cvFunc  [	storage	 		[ptr!]		; pointer to CvMemStorage	ptr		 	    [ptr!] ; pointer string	len				[integer!];CV_DEFAULT(-1)	return:			[string!]] core "cvMemStorageAllocString";Creates new empty sequence that will reside in the specified storage cvCreateSeq: cvFunc  [	seq_flags		[integer!]		header_size		[integer!]	elem_size		[integer!]	storage			[ptr!]		; pointer to CvMemStorage	return: 		[ptr!] 		;CvSeq] core "cvCreateSeq";changes default size (granularity) of sequence blocks. The default size is ~1KbytecvSetSeqBlockSize: cvFunc  [	seq				[ptr!] ;pointer to CvSeq	delta_elems		[integer!]] core "cvSetSeqBlockSize";Adds new element to the end of sequence. Returns pointer to the elementcvSeqPush: cvFunc  [	seq				[ptr!] ;pointer to CvSeq	element 		[ptr!];CV_DEFAULT(NULL) pointer	return: 		[ptr!]] core "cvSeqPush";Adds new element to the beginning of sequence. Returns pointer to itcvSeqPushFront: cvFunc  [	seq				[ptr!] ;pointer to CvSeq	element 		[ptr!];CV_DEFAULT(NULL) pointer	return: 		[ptr!]] core "cvSeqPushFront";Removes the last element from sequence and optionally saves itcvSeqPop: cvFunc  [	seq				[ptr!] ;pointer to CvSeq	element 		[ptr!];CV_DEFAULT(NULL) pointer] core "cvSeqPop";Removes the first element from sequence and optioanally saves itcvSeqPopFront: cvFunc  [	seq				[ptr!] ;pointer to CvSeq	element 		[ptr!];CV_DEFAULT(NULL) pointer] core "cvSeqPopFront"CV_FRONT: 1CV_BACK: 0;Adds several new elements to the end of sequencecvSeqPushMulti: cvFunc  [	seq				[ptr!] ;pointer to CvSeq	element 		[ptr!];CV_DEFAULT(NULL) pointer *	count			[integer!]	in_front		[integer!]; CV_DEFAULT(0)] core "cvSeqPushMulti";Removes several elements from the end of sequence and optionally saves themcvSeqPopMulti: cvFunc  [	seq				[ptr!] ;pointer to CvSeq	element 		[ptr!];CV_DEFAULT(NULL) pointer	count			[integer!]	in_front		[integer!]; CV_DEFAULT(0)] core "cvSeqPopMulti";Inserts a new element in the middle of sequence.cvSeqInsert(seq,0,elem) == cvSeqPushFront(seq,elem)cvSeqInsert: cvFunc  [	seq				[ptr!]; CvSeq	before_index	[integer!]	element 		[ptr!];CV_DEFAULT(NULL) pointer	return: 		[ptr!] ; pointer schar*] core "cvSeqInsert";Removes specified sequence elementcvSeqRemove: cvFunc  [	seq				[ptr!] ;pointer to CvSeq	index			[integer!]] core "cvSeqRemove"{Removes all the elements from the sequence. The freed memorycan be reused later only by the same sequence unless cvClearMemStorageor cvRestoreMemStoragePos is called}cvClearSeq: cvFunc  [	seq				[ptr!] ;pointer to CvSeq] core "cvClearSeq"{Retrives pointer to specified sequence element.Negative indices are supported and mean counting from the end(e.g -1 means the last sequence element)}cvGetSeqElem: cvFunc  [	seq				[ptr!] ;pointer to CvSeq	index			[integer!]	return:			[ptr!]] core "cvGetSeqElem";Calculates index of the specified sequence element. Returns -1 if element does not belong to the sequence cvSeqElemIdx: cvFunc  [	seq				[ptr!] ;pointer to CvSeq	element			[ptr!] ; pointer to void*	block			[ptr!]      ;CV_DEFAULT(NULL) ;struct! (first CvSeqBlock!)	return:			[integer!]; ] core "cvSeqElemIdx";Initializes sequence writer. The new elements will be added to the end of sequencecvStartAppendToSeq: cvFunc  [	seq				[ptr!] ;pointer to CvSeq	writer			[ptr!] ;pointer to CvSeqWriter] core "cvStartAppendToSeq";Combination of cvCreateSeq and cvStartAppendToSeqcvStartWriteSeq: cvFunc  [	seq_flags		[integer!]	header_size		[integer!]    elem_size		[integer!]    storage			[ptr!] ;CvMemStorage    writer			[ptr!];CvSeqWriter] core "cvStartWriteSeq"{Closes sequence writer, updates sequence header and returns pointer to the resultant sequence(which may be useful if the sequence was created using cvStartWriteSeq))}cvEndWriteSeq: cvFunc  [	writer			[ptr!] ;CvSeqWriter	return: 		[ptr!] ;CvSeq] core "cvEndWriteSeq"; Updates sequence header. May be useful to get access to some of previously written elements via cvGetSeqElem or sequence readercvFlushSeqWriter: cvFunc  [	writer			[ptr!]; CvSeqWriter] core "cvFlushSeqWriter";Initializes sequence reader. The sequence can be read in forward or backward directioncvStartReadSeq: cvFunc  [	seq				[ptr!]; CvSeq	reader			[ptr!]; CvSeqReader	_reverse		[integer!];CV_DEFAULT(0)] core "cvStartReadSeq";Returns current sequence reader position (currently observed sequence element)cvGetSeqReaderPos: cvFunc  [	reader			[ptr!]; CvSeqReader	return:			[integer!]] core "cvGetSeqReaderPos";Changes sequence reader position. It may seek to an absolute or to relative to the current positioncvSetSeqReaderPos: cvFunc  [	reader			[ptr!]; CvSeqReader	index			[integer!]	is_relative 	[integer!];CV_DEFAULT(0))] core "cvSetSeqReaderPos";Copies sequence content to a continuous piece of memory cvCvtSeqToArray: cvFunc  [	seq				[ptr!]; CvSeq	elements		[ptr!]; pointer	slice		 	[ptr!]; CvSlice;CV_DEFAULT(CV_WHOLE_SEQ)	return:			[ptr!]; void*] core "cvCvtSeqToArray";Creates sequence header for array.;After that all the operations on sequences that do not alter the content can be applied to the resultant sequencecvMakeSeqHeaderForArray: cvFunc  [	seq_type			[ptr!]; CvSeq	header_size		 	[integer!]	elem_size		 	[integer!]	elements			[ptr!]	; pointer void*	total				[integer!]	seq					[ptr!]; CvSeq	block				[ptr!]; CvSeqBlock	return:				[ptr!]; CvSeq] core "cvMakeSeqHeaderForArray";Extracts sequence slice (with or without copying sequence elements)cvSeqSlice: cvFunc  [	seq					[ptr!]; CvSeq	start_index 		[integer!] ; cvslice	end_index 			[integer!] ; cvslice		storage				[ptr!]; CvMemStorage;CV_DEFAULT(NULL)	copy_data			[integer!];CV_DEFAULT(NULL)	return:				[ptr!]; CvSeq] core "cvSeqSlice";inline functioncvCloneSeq: func [seq storage][    return cvSeqSlice seq 0 CV_WHOLE_SEQ_END_INDEX storage 1];Removes sequence slicecvSeqRemoveSlice: cvFunc  [	seq					[ptr!]; CvSeq	slice 				[ptr!]; CvSlice] core "cvSeqRemoveSlice";Inserts a sequence or array into another sequencecvSeqInsertSlice: cvFunc  [	seq					[ptr!]; CvSeq	before_index		[integer!]	from_arr			[ptr!] ; CvArr!] core "cvSeqInsertSlice";a < b ? -1 : a > b ? 1 : 0 CvCmpFunc: func [a b userdata][	tmp: 0	if a < b [tmp: -1]	if a > b [tmp: 1]	return tmp]CV_CDECL*: :CvCmpFunc;Sorts sequence in-place given element comparison functioncvSeqSort: cvFunc  [	seq					[ptr!]; CvSeq	CvCmpFunc			[integer!]	userdata			[ptr!];CV_DEFAULT(NULL)] core "cvSeqSort";Finds element in a [sorted] sequence cvSeqSearch: cvFunc  [	seq					[ptr!]; CvSeq	elem				[ptr!]	CvCmpFunc			[integer!]	is_sorted			[integer!]	elem_idx			[ptr!]	userdata			[ptr!];CV_DEFAULT(NULL)	return:				[ptr!]] core "cvSeqSearch";Reverses order of sequence elements in-placecvSeqInvert: cvFunc  [	seq					[ptr!]; CvSeq] core "cvSeqInvert";Splits sequence into one or more equivalence classes using the specified criteriacvSeqPartition: cvFunc  [	seq					[ptr!]; CvSeq	storage				[ptr!]; CvMemStorage	labels				[ptr!]; CvSeq** 	is_equal			[integer!]	userdata			[ptr!]	return:				[integer!]] core "cvSeqPartition";/************ Internal sequence functions ************/cvChangeSeqBlock: cvFunc[	reader				[ptr!] ; void*	direction			[integer!]] core "cvChangeSeqBlock"cvCreateSeqBlock: cvFunc  [	writer				[ptr!]; CvSeqWriter] core "cvCreateSeqBlock";Creates a new setcvCreateSet: cvFunc  [	set_flags			[integer!]	header_size			[integer!]	elem_size			[integer!]	storage				[ptr!]; CvMemStorage	return:				[ptr!]; CvSet] core "cvCreateSet";Adds new element to the set and returns pointer to itcvSetAdd: cvFunc  [	set_header			[ptr!]; CvSet	elem			    [ptr!]; struct! (first CvSetElem!)CV_DEFAULT(NULL)	inserted_elem 		[ptr!] ;CvSetElem** V_DEFAULT(NULL)	return:				[integer!]] core "cvSetAdd";inline Fast variant of cvSetAdd; DO NOT USE WITH REBOL; revoir pas bonnecvSetNew: func [set_header][	elem: set_header/free_elems;    either (elem)    [        set_header/free_elems: elem/next_free        elem/flags: elem/flags and CV_SET_ELEM_IDX_MASK        ++ set_header/active_count    ] [cvSetAdd set_header none &elem]; if rebol use address of elem (seek peek and poke func)    return elem];inline Removes set element given its pointer ;REBOL !! use CvSet! as first parameter and CvSetElem! as secondcvSetRemoveByPtr: func [set_header elem][    _elem:  make struct! [CvSetElem!] elem     assert _elem-/flags >= 0     _elem/next_free: set_header/free_elems    _elem/flags: (_elem/flags AND CV_SET_ELEM_IDX_MASK) OR CV_SET_ELEM_FREE_FLAG    set_header/free_elems:_elem;    -- set_header/active_count];Removes element from the set by its index cvSetRemove: cvFunc  [ 	set_header		[ptr!]; CvSet	index 			[integer!]] core "cvSetRemove";inline func Returns a set element by index. If the element doesn't belong to the set,NULL is returnedcvGetSetElem: func [set_header index  /local tmp tmp2][	tmp: tmp2: 0    elem: cvGetSeqElem set_header index    either CV_IS_SET_ELEM elem [tmp: 1] [tmp: 0]    to-logic elem AND tmp   ];Removes all the elements from the setcvClearSet: cvFunc  [ 	set_header		[ptr!]; CvSet] core "cvClearSet";Creates new graphcvCreateGraph: cvFunc  [	graph_flags			[integer!]	header_size			[integer!]    vtx_size			[integer!]    edge_size			[integer!]    storage				[ptr!]; CvMemStorage    return:				[ptr!]; CvGraph] core "cvCreateGraph";Adds new vertex to the graphcvGraphAddVtx: cvFunc  [	graph			[ptr!]; CvGraph	vtx				[ptr!] ;CvGraphVtx CV_DEFAULT(NULL)	inserted_vtx	[ptr!]; CvGraphVtx pointer address? CV_DEFAULT(NULL)    return:			[integer!]] core "cvGraphAddVtx";Removes vertex from the graph together with all incident edgescvGraphRemoveVtx: cvFunc  [	graph			[ptr!]; CvGraph	index			[integer!]    return:			[integer!]] core "cvGraphRemoveVtx"cvGraphRemoveVtxByPtr: cvFunc  [	graph			[ptr!]; CvGraph	vtx				[ptr!]; CvGraphVtx;CV_DEFAULT(NULL)    return:			[integer!]] core "cvGraphRemoveVtxByPtr"{Link two vertices specifed by indices or pointers if theyare not connected or return pointer to already existing edgeconnecting the vertices. Functions return 1 if a new edge was created, 0 otherwise}cvGraphAddEdge: cvFunc  [	graph			[ptr!]; CvGraph	start_idx		[integer!]	end_idx			[integer!]	edge			[ptr!]; CvGraphEdge;CV_DEFAULT(NULL)	inserted_edge	[ptr!]; CvGraphEdge;pointer address CV_DEFAULT(NULL)    return:			[integer!]] core "cvGraphAddEdge"cvGraphAddEdgeByPtr: cvFunc  [	graph			[ptr!]; CvGraph	start_vtx		[ptr!]; CvGraphVtx	end_vtx			[ptr!]; CvGraphVtx	edge			[ptr!]; CvGraphEdge;CV_DEFAULT(NULL)	inserted_edge	[ptr!]; CvGraphEdge;pointer address CV_DEFAULT(NULL)    return:			[integer!]] core "cvGraphAddEdgeByPtr";* Remove edge connecting two verticescvGraphRemoveEdge: cvFunc  [	graph			[ptr!]; CvGraph	start_idx		[integer!]	end_idx			[integer!]] core "cvGraphRemoveEdge"cvGraphRemoveEdgeByPtr: cvFunc  [	graph			[ptr!]; CvGraph	start_vtx		[ptr!]; CvGraphVtx	end_vtx			[ptr!]; CvGraphVtx] core "cvGraphRemoveEdgeByPtr";* Find edge connecting two verticescvFindGraphEdge: cvFunc  [	graph			[ptr!]; CvGraph	start_idx		[integer!]	end_idx			[integer!]	return:			[ptr!]; CvGraphEdge] core "cvFindGraphEdge"cvFindGraphEdgeByPtr: cvFunc  [	graph			[ptr!]; CvGraph	start_idx		[ptr!]; CvGraphVtx	end_idx			[ptr!]; CvGraphVtx	return:			[ptr!]; CvGraphEdge] core "cvFindGraphEdgeByPtr"alias 'cvFindGraphEdge "cvGraphFindEdge"alias 'cvFindGraphEdgeByPtr "cvGraphFindEdgeByPtr";Remove all vertices and edges from the graph cvClearGraph: cvFunc  [	graph			[ptr!]; CvGraph] core "cvClearGraph";Count number of edges incident to the vertexcvGraphVtxDegree: cvFunc  [	graph			[ptr!]; CvGraph	vtx_idx			[integer!]	return:			[integer!]] core "cvGraphVtxDegree"cvGraphVtxDegreeByPtr: cvFunc  [	graph			[ptr!]; CvGraph	vtx				[ptr!]; CvGraphVtx	return:			[integer!]] core "cvGraphVtxDegreeByPtr";Retrieves graph vertex by given indexcvGetGraphVtx: func [graph idx] [cvGetSetElem graph idx];Retrieves index of a graph vertex given its pointercvGraphVtxIdx: func [graph vtx] [vtx/flags AND CV_SET_ELEM_IDX_MASK];Retrieves index of a graph edge given its pointer */cvGraphEdgeIdx: func [graph edge] [edge/flags AND CV_SET_ELEM_IDX_MASK]cvGraphGetVtxCount: func [graph] [graph/active_count]cvGraphGetEdgeCount: func [graph] [graph/edges/active_count]CV_GRAPH_VERTEX:        1CV_GRAPH_TREE_EDGE:     2CV_GRAPH_BACK_EDGE:     4CV_GRAPH_FORWARD_EDGE:  8CV_GRAPH_CROSS_EDGE:    16CV_GRAPH_ANY_EDGE:      30CV_GRAPH_NEW_TREE:      32CV_GRAPH_BACKTRACKING:  64CV_GRAPH_OVER:          -1CV_GRAPH_ALL_ITEMS:     -1;flags for graph vertices and edges CV_GRAPH_ITEM_VISITED_FLAG:  1 shift/left 30 1CV_GRAPH_SEARCH_TREE_NODE_FLAG:  1 shift/left 29 1CV_GRAPH_FORWARD_EDGE_FLAG:      1 shift/left 28 1 IS_GRAPH_VERTEX_VISITED: func [vtx] [CV_IS_GRAPH_VERTEX_VISITED: vtx/flags and CV_GRAPH_ITEM_VISITED_FLAG] ; vtx is CvGraphVtx!IS_GRAPH_EDGE_VISITED: func [edge] [CV_IS_GRAPH_EDGE_VISITED: edge/flags and CV_GRAPH_ITEM_VISITED_FLAG]; edge is CvGraphEdge!CvGraphScanner!: make struct!  [     vtx 			[ptr!]; CvGraphVtx ; current graph vertex (or current edge origin)     dst     		[ptr!]; CvGraphVtx ; current graph edge destination vertex     edge   			[ptr!]; CvGraphEdge  ; current edge     graph      		[ptr!]; CvGraph ; the graph 	stack		    [ptr!]; CvSeq ; the graph vertex stack     index			[integer!]        ; the lower bound of certainly visited vertices     mask 			[integer!]        ; event mask ]none ;Creates new graph scannercvCreateGraphScanner: cvFunc  [	graph			[ptr!]; CvGraph	vtx 			[ptr!]; CvGraphVtx ;CV_DEFAULT(NULL)	mask			[integer!];V_DEFAULT(CV_GRAPH_ALL_ITEMS))	return:			[ptr!]; CvGraphScanner] core "cvCreateGraphScanner";Releases graph scannercvReleaseGraphScanner: cvFunc  [	scanner		[ptr!]; CvGraphScanner ; CvGraphScanner** address??] core "cvReleaseGraphScanner"; Get next graph element cvNextGraphItem: cvFunc  [	scanner		[ptr!]; CvGraphScanner	return:		[integer!]] core "cvNextGraphItem";Creates a copy of graphcvCloneGraph: cvFunc  [	graph		[ptr!]; CvGraph	storage		[ptr!]; CvMemStorage	return: 	[ptr!]; CvGraph] core "cvCloneGraph";Does look-up transformation. Elements of the source array (that should be 8uC1 or 8sC1) are used as indexes in lutarr 256-element tablecvLUT: cvFunc  [ 	src		[ptr!] ; CvArr!	dst		[ptr!] ; CvArr!	lut		[ptr!] ; CvArr!] core "cvLUT";******************* Iteration through the sequence tree *****************/CvTreeNodeIterator!: make struct!  [    node                [ptr!]		;pointeur    level               [integer!]    max_level           [integer!]  ] nonecvInitTreeNodeIterator:  cvFunc [        tree_iterator                   [ptr!]; CvTreeNodeIterator        first                           [ptr!]        max_level                       [integer!] ] core "cvInitTreeNodeIterator"   cvNextTreeNode: cvFunc [	tree_iterator        [ptr!]; CvTreeNodeIterator] core "cvNextTreeNode" cvPrevTreeNode: cvFunc  [	tree_iterator        [ptr!]; CvTreeNodeIterator] core "cvPrevTreeNode" cvInsertNodeIntoTree: cvFunc  [    "Inserts sequence into tree with specified parent sequence."        node                            [ptr!]; pointer ;*void        parent                          [ptr!]; pointer ;*void        frame                           [ptr!]; pointer ;*void] core "cvInsertNodeIntoTree"cvRemoveNodeFromTree: cvFunc  [    "Inserts sequence into tree with specified parent sequence."        node                            [ptr!]; pointer ;*void        frame                           [ptr!]; pointer ;*void] core "cvRemoveNodeFromTree"cvTreeToNodeSeq: cvFunc  [    "Gathers pointers to all the sequences, accessible from the first, to the single sequence "        first                           [ptr!]; pointer        header_size                     [integer!]        storage                         [ptr!]; CvMemStorage        return:                         [ptr!]; CvSeq ] core "cvTreeToNodeSeq"cvKMeans2: cvFunc   [        samples                         [ptr!] ; CvArr!        cluster_count                   [integer!]        labels                          [ptr!] ; CvArr!        termcrit                        [ptr!] ;CvTermCriteria] core "cvKMeans2"CV_TURN_ON_IPL_COMPATIBILITY: [(cvSetIPLAllocators iplCreateImageHeader iplAllocateImage iplDeallocate iplCreateROIiplCloneImage)];*                                    Data Persistence                                    *;********************************** High-level functions ********************************cvOpenFileStorage: cvFunc   ["opens existing or creates new file storage"        filename                [string!]        memstorage              [ptr!]; CvMemStorage        flags                   [integer!]        return                  [ptr!] ;CvFileStorage] core "cvOpenFileStorage"    cvReleaseFileStorage: cvFunc   ["closes file storage and deallocates buffers"        fs                      [ptr!]; pointer ; double pointer CvFileStorage** ] core "cvReleaseFileStorage"cvAttrValue: cvFunc  ["returns attribute value or 0 (NULL) if there is no such attribute"        attr                    [ptr!] ;CvAttrList        attr_name               [string!]        return:                 [byte!] ; 0 or null] core "cvAttrValue"     cvStartWriteStruct: cvFunc  ["starts writing compound structure (map or sequence)"        fs                      [ptr!] ;CvFileStorage        name                    [string!]        flags                   [integer!]        type_name               [string!]  ;CV_DEFAULT(NULL)        attribute               [ptr!] ;CV_DEFAULT(cvAttrList()] core "cvStartWriteStruct"cvEndWriteStruct: cvFunc  ["finishes writing compound structure"    	fs                      [ptr!] ;CvFileStorage] core "cvEndWriteStruct"cvWriteInt: cvFunc   ["writes an integer"        fs                      [ptr!] ;CvFileStorage        name                    [string!]        value                   [integer!]  ] core "cvWriteInt"        cvWriteReal: cvFunc   ["writes a floating-point number"        fs                      [ptr!] ;CvFileStorage        name                    [string!]        value                   [decimal!]  ] core "cvWriteReal" cvWriteString: cvFunc   ["writes a string"        fs                       [ptr!] ;CvFileStorage        name                    [string!]        str                     [string!]        quote                   [integer!]  ; CV_DEFAULT(0)] core "cvWriteString"cvWriteComment: cvFunc   ["writes a comment"        fs                      [ptr!] ;CvFileStorage        comment                 [string!]        eol_comment             [integer!]          ] core "cvWriteComment"cvWrite:  cvFunc   ["writes instance of a standard type (matrix, image, sequence, graph etc.)  or user-defined type"        fs                      [ptr!] ;CvFileStorage        name                    [string!]        ptr                     [ptr!]; pointer        attributes              [ptr!] ;CV_DEFAULT(cvAttrList()    ] core "cvWrite"cvStartNextStream:  cvFunc  ["starts the next stream"        fs                       [ptr!] ;CvFileStorage] core "cvStartNextStream" cvWriteRawData: cvFunc  ["helper function: writes multiple integer or floating-point numbers"        fs                      [ptr!]; CvFileStorage        src                     [ptr!]; pointer ; *void on data        len                     [integer!]        dt                      [ptr!]; pointer  ] core "cvWriteRawData"cvGetHashedKey: cvFunc   ["returns the hash entry corresponding to the specified literal key string or 0 if there is no such a key in the storage"        fs                      [ptr!]; CvFileStorage        name                    [string!]        len                     [integer!]        create_missing          [integer!] ;CV_DEFAULT(0)        return:                 [ptr!]; CvStringHashNode] core "cvGetHashedKey"cvGetRootFileNode: cvFunc   ["returns file node with the specified key within the specified map (collection of named nodes)"        fs                      [ptr!]; CvFileStorage        stream_index            [integer!]        return:                 [ptr!]; CvFileNode] core "cvGetRootFileNode"cvGetFileNodeByName: cvFunc   [    "this is a slower version of cvGetFileNode that takes the key as a literal string"        fs                      [ptr!]; CvFileStorage        map                     [ptr!]; CvFileNode        name                    [string!]        return:                 [ptr!]; CvFileNode] core "cvGetFileNodeByName"cvRead: cvFunc   ["decodes standard or user-defined object and returns it"        fs                      [ptr!]; CvFileStorage        node                    [ptr!]; CvFileNode        attributes             [ptr!]; CvAttrList ;CV_DEFAULT(NULL)    ] core "cvRead"cvReadRawDataSlice: cvFunc [	"reads multiple numbers and stores them to array"	fs			[ptr!]	;CvFileStorage	reader		[ptr!]	;CvSeqReader	count		[integer!]	dst			[ptr!]	dt			[string!]] core "cvReadRawDataSlice"cvStartReadRawData: cvFunc   ["starts reading data from sequence or scalar numeric node"        fs                      [ptr!]; CvFileStorage        src                     [ptr!]; CvFileNode        reader                  [ptr!]; CvSeqReader] core "cvStartReadRawData"cvReadRawData: cvFunc   ["combination of two previous functions for easier reading of whole sequences"        fs                      [ptr!]; CvFileStorage        src                     [ptr!]; CvFileNode        dst                     [ptr!]; pointer         dt                      [integer!]] core "cvReadRawData"cvWriteFileNode: cvFunc   ["writes a copy of file node to file storage"        fs                      [ptr!]; CvFileStorage        new_node_name           [string!]        node                    [ptr!]; CvFileNode        embed                   [integer!]] core "cvWriteFileNode"cvGetFileNodeName: cvFunc   [    "returns name of file node"     node                       [ptr!]; CvFileNode     return:                    [string!]] core "cvGetFileNodeName";*********************************** Adding own types ***********************************cvRegisterType: cvFunc  [info [ptr!]] core "cvRegisterType"cvUnregisterType: cvFunc  [type_name [string!]] core "cvUnregisterType"cvFirstType:  cvFunc  [ return:    [ptr!]] core "cvFirstType"cvFindType:  cvFunc  [type_name [string!] return: [ptr!]] core "cvFindType"cvTypeOf: cvFunc   [struct_ptr [ptr!] return: [ptr!]] core "cvTypeOf"cvClone:  cvFunc   [struct_ptr [ptr!] return: [ptr!]] core "cvClone";universal functionscvRelease:  cvFunc [struct_ptr [ptr!]] core "cvRelease"cvClone: cvFunc [struct_ptr [ptr!]] core "cvClone" ;simple API for reading/writing datacvSave: cvFunc  [        filename                [string!]        struct_ptr              [ptr!]; pointer        name                    [string!]     ;CV_DEFAULT(NULL)        comment                 [string!]     ;CV_DEFAULT(NULL)        attributes              [ptr!]; CvAttrList  ;CV_DEFAULT(cvAttrList() ] core "cvSave"cvLoad: cvFunc   [		filename				[string!]        memstorage              [ptr!]; CvMemStorage        name                    [ptr!];[string!]     ;CV_DEFAULT(NULL)        real_name               [ptr!];struct! (first ptr!-ptr!)]        return:					[long] ;void*] core "cvLoad";*********************************** Measuring Execution Time ***************************;helper functions for RNG initialization and accurate time measurement: uses internal clock counter on x86 cvGetTickCount:  cvFunc  [return: [decimal!]] core "cvGetTickCount"cvGetTickFrequency:  cvFunc  [return: [decimal!]] core "cvGetTickFrequency";/*********************************** CPU capabilities ***********************************/CV_CPU_NONE:    0CV_CPU_MMX:     1CV_CPU_SSE:     2CV_CPU_SSE2:    3CV_CPU_SSE3:    4CV_CPU_SSSE3:   5CV_CPU_SSE4_1:  6CV_CPU_SSE4_2:  7CV_CPU_POPCNT:  8CV_CPU_AVX:    10CV_HARDWARE_MAX_FEATURE: 255cvCheckHardwareSupport: cvFunc [	feature		[integer!]	return:		[integer!]] core "cvCheckHardwareSupport";*********************************** Multi-Threading ************************************cvGetNumThreads: cvFunc [return: [integer!]] core "cvGetNumThreads" cvSetNumThreads:  cvFunc [threads [integer!]] core "cvSetNumThreads";get index of the thread being executedcvGetThreadNum:  cvFunc [return: [integer!]] core "cvGetThreadNum"   ;********************************** Error Handling **************************************;Get current OpenCV error statuscvGetErrStatus: cvFunc [return: [integer!]] core "cvGetErrStatus";Sets error status silentlycvSetErrStatus: cvFunc [status [integer!]] core "cvSetErrStatus"    CV_ErrModeLeaf:     0   ;Print error and exit programCV_ErrModeParent:   1   ;Print error and continueCV_ErrModeSilent:   2   ;Don't print and continue;Retrives current error processing modecvGetErrMode: cvFunc [return: [integer!]] core "cvGetErrMode";Sets error processing mode, returns previously used modecvSetErrMode: cvFunc [mode [integer!] return: [integer!]] core "cvSetErrMode"cvError:  cvFunc ["Sets error status and performs some additonal actions (displaying message box,writing message to stderr, terminating application etc.)"        status              [integer!]        func_name           [string!]        err_msg             [string!]        file_name           [string!]        line                [integer!]] core "cvError"    cvErrorStr: cvFunc ["Retrieves textual description of the error given its code"        status              [integer!]        return:             [string!]     ] core "cvErrorStr"cvGetErrInfo: cvFunc  ["Retrieves detailed information about the last error occured"        errcode_desc            [ptr!]; pointer ;char**        description             [ptr!]; pointer ;char**        filename                [ptr!]; pointer ;char**        line                    [ptr!]; pointer        return:                 [integer!]    ] core "cvGetErrInfo"cvErrorFromIppStatus: cvFunc  ["Maps IPP error codes to the counterparts from OpenCV"        ipp_status              [integer!]        return:                 [integer!]   ] core "cvErrorFromIppStatus";RED/S version of orginal typedef ptr! (CV_CDECL *CvErrorCallback)CvErrorCallback!: make struct! [    status              [integer!]    func_name           [string!]    err_msg             [string!]    file_name           [string!]    line                [integer!]    userdata            [ptr!]   ; pointer] nonecvRedirectError: cvFunc   [        error_handler           [ptr!] ;CvErrorCallback        userdata                [ptr!]; pointer         ;void*        prev_userdata           [ptr!]; pointer  ; double pointer void**] core "cvRedirectError";Output to:;    cvNulDevReport - nothing;    cvStdErrReport - console(fprintf(stderr,...));    cvGuiBoxReport - MessageBox(WIN32)cvNulDevReport: cvFunc  [        status              [integer!]        func_name           [string!]        err_msg             [string!]        file_name           [string!]        line                [integer!]        userdata            [ptr!]; pointer        return:             [integer!]] core "cvNulDevReport"cvStdErrReport: cvFunc   [        status              [integer!]        func_name           [string!]        err_msg             [string!]        file_name           [string!]        line                [integer!]        userdata            [ptr!]; pointer        return:             [integer!]] core "cvStdErrReport"     cvGuiBoxReport: cvFunc   [        status              [integer!]        func_name           [string!]        err_msg             [string!]        file_name           [string!]        line                [integer!]        userdata            [ptr!]; pointer        return:             [integer!]] core "cvGuiBoxReport"