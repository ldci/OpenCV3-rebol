REBOL[	Title:		"OpenCV Binding: imgproc_c.r"	Author:		"François Jouen"	Rights:		"Copyright (c) 2014 François Jouen. All rights reserved."	License: 	"BSD-3 - https:;github.com/dockimbel/Red/blob/master/BSD-3-License.txt"];*********************** Background statistics accumulation *****************************/cvAcc: cvFunc [	"Adds image to accumulator"	image		[ptr!]	;CvArr*	sum			[ptr!]	;CvArr*	mask		[ptr!] 	;CV_DEFAULT(NULL)] imgproc "cvAcc"cvSquareAcc: cvFunc [	"Adds squared image to accumulator"	image		[ptr!]	;CvArr*	sqsum		[ptr!]	;CvArr*	mask		[ptr!] 	;CV_DEFAULT(NULL)] imgproc "cvSquareAcc"cvMultiplyAcc: cvFunc [	"Adds a product of two images to accumulator"	image1		[ptr!]	;CvArr*	image2		[ptr!]	;CvArr*	acc			[ptr!]	;CvArr*	mask		[ptr!] 	;CV_DEFAULT(NULL)] imgproc "cvMultiplyAcc" cvRunningAvg: cvFunc [	"Adds image to accumulator with weights: acc = acc*(1-alpha) + image*alpha"	image		[ptr!]	;CvArr*	acc			[ptr!]	;CvArr*	alpha		[decimal!]	;	mask		[ptr!] 	;CV_DEFAULT(NULL)] imgproc "cvRunningAvg" ;/****************************************************************************************\;*                                    Image Processing                                    *;\****************************************************************************************/;Copies source 2D array inside of the larger destination array and;makes a border of the specified type (IPL_BORDER_*) around the copied area. */                             cvCopyMakeBorder: cvFunc  [	"Copies source 2D array inside of the larger destination array and makes a border of the specified type (IPL_BORDER_*) around the copied area"	src 	[ptr!];         CvArr!	dst 	[ptr!];         CvArr!	x  		[integer!] ; in fact CvPoint	y		[integer!]	bordertype [integer!]	v0 	[integer!] ;CvScalar CV_DEFAULT(cvScalarAll(0))		v1	[integer!]	v2 	[integer!]	v3 	[integer!]] imgproc  "cvCopyMakeBorder"  cvSmooth: cvFunc  [	"Smoothes array (removes noise)" 	src 		[ptr!]; [struct! (first CvArr!)]	dst 		[ptr!]; [struct! (first CvArr!)]	smoothtype 	[integer!] ; CV_DEFAULT(CV_GAUSSIAN)	size1		[integer!] ; CV_DEFAULT(3)	size2		[integer!] ; CV_DEFAULT(0)	sigma1		[decimal!] ; CV_DEFAULT(0)	sigma2		[decimal!] ; CV_DEFAULT(0)	] imgproc "cvSmooth"cvFilter2D: cvFunc  [	"Convolves the image with the kernel" 	src 		[ptr!];         CvArr!	dst 		[ptr!];         CvArr!	kernel		[ptr!] ;CvMat	x  			[integer!] ; in fact CvPoint 	y			[integer!] ;CV_DEFAULT(cvPoint(-1,-1))] imgproc "cvFilter2D"cvIntegral: cvFunc  [	"Finds integral image: SUM(X,Y) = sum(x<X,y<Y)I(x,y)"	image 		[ptr!];         CvArr!	sum 		[ptr!];         CvArr!	sqsum		[ptr!];         CvArr! ;CV_DEFAULT(NULL) none	tilted_sum	[ptr!];         CvArr! ;CV_DEFAULT(NULL) none	] imgproc "cvIntegral";dst_width = floor(src_width/2)[+1],;dst_height = floor(src_height/2)[+1]   cvPyrDown: cvFunc [	"Smoothes the input image with gaussian kernel and then down-samples it." 	src 		[ptr!] ; [struct! (first CvArr!)]	dst 		[ptr!] ;[struct! (first CvArr!)]	filter		[integer!]; CV_DEFAULT(CV_GAUSSIAN_5x5)] imgproc "cvPyrDown"                   ;dst_width = src_width*2, dst_height = src_height*2cvPyrUp: cvFunc [	"Up-samples image and smoothes the result with gaussian kernel."	src 		[ptr!];         CvArr!	dst 		[ptr!];         CvArr!	filter		[integer!]; CV_DEFAULT(CV_GAUSSIAN_5x5)] imgproc "cvPyrUp"cvCreatePyramid: cvFunc  [	"Builds pyramid for an image "	img 			[ptr!];         CvArr!	extra_layers	[integer!]	rate			[decimal!]	layer_sizes		[integer!]; pointer to CvSize* ; CV_DEFAULT(0),	bufarr 			[integer!] ; CV_DEFAULT(0)	calc			[integer!]; CV_DEFAULT(1)	filter			[integer!]; CV_DEFAULT(CV_GAUSSIAN_5x5)	return 			[integer!] ;a double pointer CvMat**] imgproc "cvCreatePyramid"cvReleasePyramid: cvFunc  [	"Releases pyramid"	pyramid			[integer!] ; pointer CvMat***	extra_layers	[integer!]] imgproc "cvReleasePyramid"cvPyrMeanShiftFiltering: cvFunc  [	"Filters image using meanshift algorithm"	src 		[ptr!];         CvArr!	dst 		[ptr!];         CvArr!	sp			[decimal!]	sr			[decimal!]	max_level	[integer!] ;  CV_DEFAULT(1)	termcrit	[ptr!] ; CV_DEFAULT(cvTermCriteria(CV_TERMCRIT_ITER+CV_TERMCRIT_EPS,5,1)))] imgproc "cvPyrMeanShiftFiltering"cvWatershed: cvFunc  [	"Segments image using seed markers"	src 		[ptr!];         CvArr!	markers 	[ptr!];         CvArr!] imgproc "cvWatershed"{ Calculates an image derivative using generalized Sobel(aperture_size = 1,3,5,7) or Scharr (aperture_size = -1) operator.Scharr can be used only for the first dx or dy derivative }cvSobel: cvFunc  [	"Calculates an image derivative using generalized Sobel" 	src 			[ptr!];         CvArr!	dst 			[ptr!];         CvArr!	xorder			[integer!]	yorder			[integer!]	aperture_size	[integer!];  CV_DEFAULT(3)] imgproc "cvSobel"cvLaplace: cvFunc  ["Calculates the image Laplacian: (d2/dx + d2/dy)I"            src 			[ptr!] ; CvArr!            dst 			[ptr!] ; CvArr!            aperture_size	[integer!];  CV_DEFAULT(3)] imgproc "cvLaplace"      ;cvCvtColor: cvFunc  [	"Converts input array pixels from one color space to another "	src 			[ptr!];[struct! (first CvArr!)]	dst 			[ptr!]; [struct! (first CvArr!)]	code			[integer!]] imgproc "cvCvtColor"cvResize: cvFunc  [	"Resizes image (input array is resized to fit the destination array)" 	src 			[ptr!];         CvArr!	dst 			[ptr!];         CvArr!	interpolation	[integer!] ;CV_DEFAULT( CV_INTER_LINEAR ))] imgproc "cvResize"cvWarpAffine: cvFunc  [	"Warps image with affine transform"	src 			[ptr!];         CvArr!	dst 			[ptr!];         CvArr!	map_matrix		[ptr!] ; CvMAt!	flags			[integer!] ;CV_DEFAULT(CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS)	fillval			[ptr!] ;CV_DEFAULT(cvScalarAll(0))] imgproc "cvWarpAffine";cvGetAffineTransform: cvFunc  [	"computes affine transform matrix for mapping src[i] to dst[i] (i=0,1,2) "	src 			[ptr!] 	;CvPoint2D32f	dst 			[ptr!] 	;CvPoint2D32f	map_matrix		[ptr!]	;CvMat	return:			[ptr!] 	;CvMat] imgproc "cvGetAffineTransform"cv2DRotationMatrix: cvFunc  [	"Computes rotation_matrix matrix" 	center 			[ptr!] 	;CvPoint2D32f	angle 			[decimal!]	scale			[decimal!]	map_matrix		[ptr!]	;CvMat	return:			[ptr!]	;CvMat] imgproc "cv2DRotationMatrix"cvWarpPerspective: cvFunc  [	"Warps image with perspective (projective) transform" 	src 			[ptr!];         CvArr!	dst 			[ptr!];         CvArr!	map_matrix		[ptr!]	;CvMat	flags			[integer!] ;CV_DEFAULT(CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS)	v0 	[integer!] ;CvScalar CV_DEFAULT(cvScalarAll(0))		v1	[integer!]	v2 	[integer!]	v3 	[integer!]] imgproc "cvWarpPerspective"cvGetPerspectiveTransform: cvFunc  [	"Computes perspective transform matrix for mapping src[i] to dst[i] (i=0,1,2,3)" 	src 			[ptr!] 	;CvPoint2D32f	dest 			[ptr!] 	;CvPoint2D32f	map_matrix		[ptr!]	;CvMat	return:			[ptr!]	;CvMat] imgproc "cvGetPerspectiveTransform"cvRemap: cvFunc  [	"Performs generic geometric transformation using the specified coordinate maps"	src 			[ptr!];         CvArr!	dst 			[ptr!];         CvArr!	mapx			[ptr!];         CvArr!	mapy			[ptr!];         CvArr!	flags			[integer!] ;CV_DEFAULT(CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS)	v0 				[integer!] ;CvScalar CV_DEFAULT(cvScalarAll(0))		v1				[integer!]	v2 				[integer!]	v3 				[integer!]] imgproc "cvRemap"cvConvertMaps: cvFunc [	"Converts mapx & mapy from floating-point to integer formats for cvRemap"	mapx			[ptr!];         CvArr!	mapy			[ptr!];         CvArr!	mapxy			[ptr!];         CvArr!	mapalpha		[ptr!];         CvArr!] imgproc "cvConvertMaps";cvLogPolar: cvFunc  [	"Performs forward or inverse log-polar image transform"	src 			[ptr!];         CvArr!	dest 			[ptr!];         CvArr!	center_x		[decimal!] ;CvPoint2D32f	center_y		[decimal!]	m				[decimal!]	flags			[integer!] ;CV_DEFAULT(CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS)] imgproc "cvLogPolar";Performs forward or inverse linear-polar image transform */cvLinearPolar: cvFunc  [	"Performs forward or inverse log-polar image transform"	src 			[ptr!];         CvArr!	dest 			[ptr!];         CvArr!	center_x		[decimal!] ;CvPoint2D32f	center_y		[decimal!]	maxRadius		[decimal!]	flags			[integer!] ;CV_DEFAULT(CV_INTER_LINEAR+CV_WARP_FILL_OUTLIERS)] imgproc "cvLinearPolar"cvUndistort2: cvFunc [	"Transforms the input image to compensate lens distortion" 	src 				[ptr!];         CvArr!	dest 				[ptr!];         CvArr!	camera_matrix		[ptr!];         CvArr!	distortion_coeffs	[ptr!];         CvArr!	new_camera_matrix	[ptr!];         CvArr! CV_DEFAULT(0)] imgproc "cvUndistort2" cvInitUndistortMap: cvFunc [	"Computes transformation map from intrinsic camera parameters that can used by cvRemap" 	camera_matrix		[ptr!];         CvArr!	distortion_coeffs	[ptr!];         CvArr!	mapx				[ptr!];         CvArr!	mapy				[ptr!];         CvArr!] imgproc "cvInitUndistortMap" cvInitUndistortRectifyMap: cvFunc [	"Computes undistortion+rectification map for a head of stereo camera"	camera_matrix		[ptr!];         CvArr!	distortion_coeffs	[ptr!];         CvArr!	R					[ptr!];         CvArr!	new_camera_matrix	[ptr!];         CvArr!	mapx				[ptr!];         CvArr!	mapy				[ptr!];         CvArr!] imgproc "cvInitUndistortRectifyMap" cvUndistortPoints: cvFunc [	"Computes the original (undistorted) feature coordinates from the observed (distorted) coordinates" 	src 				[ptr!];         CvArr!	dest 				[ptr!];         CvArr!	camera_matrix		[ptr!];         CvArr!	distortion_coeffs	[ptr!];         CvArr!	R					[ptr!];         CvArr! CV_DEFAULT	P					[ptr!];         CvArr! CV_DEFAULT] imgproc "cvUndistortPoints" cvCreateStructuringElementEx: cvFunc  [	"creates structuring element used for morphological operations"	cols		[integer!]	rows		[integer!]	anchor_x	[integer!]	anchor_y	[integer!]	shapes		[integer!]	values		[integer!] 	; pointer to values CV_DEFAULT(NULL)	return:		[ptr!]		;IplConvKernel] imgproc "cvCreateStructuringElementEx" cvReleaseStructuringElement: cvFunc  [	"releases structuring element"	IplConvKernel**		[ptr!]; double pointer] imgproc "cvReleaseStructuringElement";If element pointer is NULL, 3x3 rectangular element is usedcvErode: cvFunc  [	"erodes input image (applies minimum filter) one or more times."	src 			[ptr!]; CvArr!	dest 			[ptr!];CvArr!	element			[ptr!] ; pointer IplConvKernel!  CV_DEFAULT(NULL)	iterations		[integer!] ;CV_DEFAULT(1)] imgproc "cvErode";If element pointer is NULL, 3x3 rectangular element is used cvDilate: cvFunc  [	"dilates input image (applies maximum filter) one or more times."	src 			[ptr!]; CvArr!	dest 			[ptr!]; CvArr!	element			[ptr!] ; pointer IplConvKernel!  CV_DEFAULT(NULL)	iterations		[integer!] ;CV_DEFAULT(1)] imgproc "cvDilate"cvMorphologyEx: cvFunc  [	"Performs complex morphological transformation"	src 			[ptr!]	;CvArr!	dest 			[ptr!]	;CvArr!	temp 			[ptr!]	;CvArr!	element			[ptr!] 	;pointer IplConvKernel!  CV_DEFAULT(NULL)	operation		[integer!] ;CV_DEFAULT(1)	iterations		[integer!] ;CV_DEFAULT(1)] imgproc "cvMorphologyEx"cvMoments: cvFunc  [	"Calculates all spatial and central moments up to the 3rd order "	arr 			[ptr!]		;CvArr!	moments 		[ptr!] 		;CvMoments!	binary			[integer!] 	;CV_DEFAULT(0)] imgproc "cvMoments"cvGetSpatialMoment: cvFunc  [	"Retrieve particular spatial moments "	moments 		[ptr!] 		;CvMoments!	x_order			[integer!] 	y_order			[integer!] 	return:			[decimal!]] imgproc "cvGetSpatialMoment"cvGetCentralMoment: cvFunc  [	"Retrieve particular central moments "	moments 		[ptr!] 		;CvMoments!	x_order			[integer!] 	y_order			[integer!] 	return:			[decimal!]] imgproc "cvGetCentralMoment"cvGetNormalizedCentralMoment: cvFunc  ["Retrieve particular normalized central moments "	moments 		[ptr!] 		;CvMoments!	x_order			[integer!] 	y_order			[integer!] 	return:			[decimal!]] imgproc "cvGetNormalizedCentralMoment"cvGetHuMoments: cvFunc  [	"Calculates 7 Hu's invariants from precalculated spatial and central moments"	moments 		[ptr!] 		;CvMoments!	hu_moments 		[ptr!] 		;CvMoments!] imgproc "cvGetHuMoments";/*********************************** data sampling **************************************/cvSampleLine: cvFunc  [	"Fetches pixels that belong to the specified line segment and stores them to the buffer. Returns the number of retrieved points."	image 			[ptr!];         CvArr!	pt1_x	 		[integer!];CvPoint	pt1_y	 		[integer!];CvPoint	pt2_x	 		[integer!];CvPoint	pt2_y	 		[integer!];CvPoint	void*	 		[ptr!] ; pointer	connectivity	[integer!] ;CV_DEFAULT(8)	return:			[integer!]] imgproc "cvSampleLine"{Retrieves the rectangular image region with specified center from the input array. dst(x,y) <- src(x + center.x - dst_width/2, y + center.y - dst_height/2). Values of pixels with fractional coordinates are retrieved using bilinear interpolation}cvGetRectSubPix: cvFunc  [	"Retrieves the rectangular image region with specified center from the input array"	src 			[ptr!];         CvArr!	dst 			[ptr!];         CvArr!	center	 		[ptr!] ; CvPoint2D32f!] imgproc "cvGetRectSubPix"{Retrieves quadrangle from the input array.matrixarr = ( a11  a12 | b1 )   dst(x,y) <- src(A[x y]' + b)( a21  a22 | b2 )   (bilinear interpolation is used to retrieve pixels with fractional coordinates)}cvGetQuadrangleSubPix: cvFunc  [	"Retrieves quadrangle from the input array"	src 			[ptr!];         CvArr!	dst 			[ptr!];         CvArr!	map_matrix 		[ptr!];         CvArr!] imgproc "cvGetQuadrangleSubPix";Measures similarity between template and overlapped windows in the source image ;and fills the resultant image with the measurements cvMatchTemplate: cvFunc  [	"Measures similarity between template and overlapped windows"	image 			[ptr!];         CvArr!	temp1 			[ptr!];         CvArr!	result	 		[ptr!];         CvArr!	method			[integer!]] imgproc "cvMatchTemplate"cvCalcEMD2: cvFunc  [	"Computes earth mover distance between two weighted point sets (called signatures)"	signature1 			[ptr!];         CvArr!	signature2 			[ptr!];         CvArr!	distance_type		[integer!]	distance_func 		[ptr!] ; pointer CV_DEFAULT(NULL)	cost_matrix	 		[ptr!];         CvArr!; CV_DEFAULT(NULL)	flow				[ptr!];         CvArr!; CV_DEFAULT(NULL)	lower_bound			[decimal!];  CV_DEFAULT(NULL)	userdata			[ptr!]; null pointer CV_DEFAULT(NULL));] imgproc "cvCalcEMD2";/****************************************************************************************\;*                              Contours retrieving                                       *;\****************************************************************************************/cvFindContours: cvFunc  [	"Retrieves outer and optionally inner boundaries of white (non-zero) connected components in the black (zero) background"	image 			[ptr!]		;CvArr!	storage 		[ptr!]		;CvMemStorage!	first_contour	[ptr!] 		;CvSeq**	header_size		[integer!]	;CV_DEFAULT(sizeof(CvContour))	mode			[integer!]	;CV_DEFAULT(CV_RETR_LIST)	method			[integer!]	;CV_DEFAULT(CV_CHAIN_APPROX_SIMPLE)	offset_x		[integer!]	;cvPoint CV_DEFAULT(cvPoint(0,0))	offset_y		[integer!]	;cvPoint CV_DEFAULT(cvPoint(0,0))	return: 		[integer!]] imgproc "cvFindContours"{Initalizes contour retrieving process. Calls cvStartFindContours.Calls cvFindNextContour until null pointer is returned or some other condition becomes true.Calls cvEndFindContours at the end.}cvStartFindContours: cvFunc  [	"Initalizes contour retrieving process"	image 			[ptr!]		;CvArr!	storage 		[ptr!]		;CvMemStorage!	header_size		[integer!]	;CV_DEFAULT(sizeof(CvContour))	mode			[integer!]	;CV_DEFAULT(CV_RETR_LIST)	method			[integer!]	;CV_DEFAULT(CV_CHAIN_APPROX_SIMPLE)	offset_x		[integer!]	; cvPoint CV_DEFAULT(cvPoint(0,0))	offset_y		[integer!]	;cvPoint CV_DEFAULT(cvPoint(0,0))	return: 		[ptr!]		; pointer to CvContourScanner] imgproc "cvStartFindContours"cvFindNextContour: cvFunc  [	"Retrieves next contour"	scanner 	[ptr!]	;CvContourScanner	return: 	[ptr!]	;CvSeq!	] imgproc "cvFindNextContour" ;(if the substitutor is null, the last retrieved contour is removed from the tree)cvSubstituteContour: cvFunc  [	"Substitutes the last retrieved contour with the new one "	scanner 	[ptr!]	;CvContourScanner	new_contour [ptr!]	;CvSeq!	] imgproc "cvFindNextContour"cvEndFindContours: cvFunc  [	"Releases contour scanner and returns pointer to the first outer contour"	scanner 	[ptr!]	;CvContourScanner	return: 	[ptr!]	;CvSeq!	] imgproc "cvEndFindContours"cvApproxChains: cvFunc  [	"Approximates a single Freeman chain or a tree of chains to polygonal curves"	src_seq				[ptr!]		;CvSeq!		storage				[ptr!]		;CvMemStorage!	method				[decimal!]	;CV_DEFAULT(0)	parameter			[integer!]	;CV_DEFAULT(0)	minimal_perimeter	[integer!]	;CV_DEFAULT(0)	recursive			[integer!]	;CV_DEFAULT(0)	return: 			[ptr!]		;CvSeq!]imgproc "cvApproxChains"{The reader is used to iteratively get coordinates of all the chain points.If the Freeman codes should be read as is, a simple sequence reader should be used}cvStartReadChainPoints: cvFunc  [	"Initalizes Freeman chain reader"	chain		[ptr!] ;CvChain!	reader		[ptr!] ;CvChainPtReader!] imgproc "cvStartReadChainPoints" cvReadChainPoint: cvFunc  [	"Retrieves the next chain point"	reader		[ptr!] ;CvChainPtReader!	return:		reduce [integer! integer!] ;CvPoint] imgproc "cvReadChainPoint";*************************** Contour Processing and Shape Analysis *************************cvApproxPoly: cvFunc  ["Approximates a single polygonal curve (contour) or a tree of polygonal curves (contours)"	src_seq                     [ptr!] 		;void*    header_size                 [integer!]	storage                     [ptr!]		;CvMemStorage!	method                      [integer!]	parameter                   [decimal!]	parameter2                  [integer!] 	;CV_DEFAULT(0)	return:                     [ptr!] 		;CvSeq!] imgproc "cvApproxPoly"cvArcLength: cvFunc  ["Calculates perimeter of a contour or length of a part of contour"	curve                       [ptr!] 		;void*	slice_start_index           [integer!]; _CvSlice  ;CV_DEFAULT(CV_WHOLE_SEQ)	slice_end_index             [integer!]	is_closed                   [integer!]   ; CV_DEFAULT(-1)	return:                     [decimal!]] imgproc "cvArcLength"cvContourPerimeter: func [[contour]] [cvArcLength contour CV_WHOLE_SEQ 1]cvBoundingRect: cvFunc  ["Calculates contour boundning rectangle (update=1) or just retrieves pre-calculated rectangle (update=0)"	points                      [ptr!];         CvArr!	update                      [integer!] ;CV_DEFAULT(0)	return:                     [cvRect!]; not a pointer just a struct] imgproc "cvBoundingRect"cvContourArea: cvFunc ["Calculates area of a contour or contour segment"	points                      [ptr!];         CvArr!	slice_start_index           [integer!] ;_CvSlice CV_DEFAULT(CV_WHOLE_SEQ))	slice_end_index             [integer!] ;_CvSlice CV_DEFAULT(CV_WHOLE_SEQ))	return:                     [decimal!]] imgproc "cvContourArea"cvMinAreaRect2: cvFunc   ["Finds minimum area rotated rectangle bounding a set of points"	points		[ptr!];         CvArr!	storage	[ptr!] ; CvMemStorage!CV_DEFAULT(NULL)	return:    [CvBox2D!];  not pointer] imgproc "cvMinAreaRect2"cvMinEnclosingCircle: cvFunc  ["Finds minimum enclosing circle for a set of points"	points	[ptr!];         CvArr!	center	[ptr!] ;*  CvPoint2D32f! pointer	radius	[ptr!]	; *float	return:	[integer!]] imgproc "cvMinEnclosingCircle"cvMatchShapes: cvFunc  ["Compares two contours by matching their moments"	object1		[ptr!]	object2		[ptr!]	method		[integer!]	parameter	[decimal!]	return:		[decimal!]] imgproc "cvMatchShapes" cvConvexHull2: cvFunc   ["Calculates exact convex hull of 2d point set"	input			[ptr!];         CvArr!	hull_storage	[ptr!] ; void * ;CV_DEFAULT(NULL)	orientation		[integer!]  ;CV_DEFAULT(CV_CLOCKWISE)	return_points	[integer!]   ;CV_DEFAULT(0)	return:			[ptr!];CvSeq!] imgproc "cvConvexHull2"cvCheckContourConvexity: cvFunc  ["Checks whether the contour is convex or not (returns 1 if convex, 0 if not)"	contour		[ptr!];         CvArr!	return:		[integer!]] imgproc "cvCheckContourConvexity"cvConvexityDefects: cvFunc  [	"Finds convexity defects for the contour"	contour		[ptr!];         CvArr!	convexhull	[ptr!];         CvArr!	storage		[ptr!] ;CvMemStorage! CV_DEFAULT(NULL)	return:		[ptr!] ;CvSeq] imgproc "cvConvexityDefects"cvFitEllipse2: cvFunc  ["Fits ellipse into a set of 2d points"	points		[ptr!];         CvArr!	return:		[CvBox2D!] ;  may be problematic] imgproc "cvFitEllipse2"cvMaxRect: cvFunc   ["Finds minimum rectangle containing two given rectangles"	rect1                       [ptr!] ;CvRect!	rect2                       [ptr!] ;CvRect!	return:                     [CvRect!] ; may be problematic] imgproc "cvMaxRect"cvBoxPoints: cvFunc   ["Finds coordinates of the box vertices "	box_center_x                    [decimal!]  ;CvBox2D	box_center_y                    [decimal!]  ;CvBox2D	box_size_width                  [decimal!]  ;CvBox2D	box_size_height                 [decimal!]  ;CvBox2D	box_angle                       [decimal!]  ;CvBox2D	pt_4                            [ptr!] ; pointeur array 4 float32] imgproc "cvBoxPoints"cvPointSeqFromMat: cvFunc   ["Initializes sequence header for a matrix (column or row vector) of points - a wrapper for cvMakeSeqHeaderForArray (it does not initialize bounding rectangle!!!)"	seq_kind                        [integer!]	mat                             [ptr!]		;CvArr!	contour_header                  [ptr!]		;CvContour!	block                           [ptr!]		;CvSeqBlock!)	return:                         [ptr!]		; CvSeq!] imgproc "cvPointSeqFromMat"{Checks whether the point is inside polygon, outside, on an edge (at a vertex).Returns positive, negative or zero value, correspondingly.Optionally, measures a signed distance betweenthe point and the nearest polygon edge (measure_dist=1)}cvPointPolygonTest: cvFunc  [   "Checks whether the point is inside polygon, outside, on an edge (at a vertex). "   	contour                         [ptr!]		;CvArr!	pt_x                            [decimal!]	;CvPoint2D32f	pt_y                            [decimal!]	measure_dist                    [integer!]	return:                         [decimal!]] imgproc "cvPointPolygonTest";*********************************** Histogram functions ****************************cvCreateHist: cvFunc  ["Creates new histogram"	dims                            [integer!]	sizes                           [ptr!]	type                            [integer!]	ranges                          [ptr!]			; ** float CV_DEFAULT(NULL)	uniform                         [integer!]		;CV_DEFAULT(1)	return:                         [ptr!]			;CvHistogram!] imgproc "cvCreateHist"cvSetHistBinRanges: cvFunc  ["Assignes histogram bin ranges"	hist                            [ptr!] 		;CvHistogram!	ranges                          [ptr!]		; **float	uniform                         [integer!]	;CV_DEFAULT(1)] imgproc "cvSetHistBinRanges"cvMakeHistHeaderForArray: cvFunc  ["Creates histogram header for array"	dims                            [integer!]	sizes                           [ptr!]	hist                            [ptr!] 		;CvHistogram!	data                           	[ptr!]	ranges                          [ptr!]		; ** float CV_DEFAULT(NULL)	uniform                         [integer!]	return:                         [ptr!] 		;CvHistogram!] imgproc "cvMakeHistHeaderForArray"cvReleaseHist: cvFunc  ["Releases histogram"    CvHistogram	[ptr!] ] imgproc "cvReleaseHist"cvClearHist: cvFunc   ["Clears histogram"	hist	[ptr!] 		;CvHistogram!] imgproc "cvClearHist"cvGetMinMaxHistValue: cvFunc  ["Finds indices and values of minimum and maximum histogram bins"	hist		[ptr!] ;CvHistogram!	min_value   [ptr!] ; float	max_value   [ptr!]	;float	min_idx     [ptr!] ;CV_DEFAULT(NULL)	max_idx   	[ptr!] ;CV_DEFAULT(NULL)] imgproc "cvGetMinMaxHistValue"cvNormalizeHist:  cvFunc  ["Normalizes histogram by dividing all bins by sum of the bins, multiplied by <factor>. After that sum of histogram bins is equal to <factor>"	hist	[ptr!] ;CvHistogram!	factor	[decimal!]] imgproc "cvNormalizeHist"cvThreshHist: cvFunc   ["Clear all histogram bins that are below the threshold"	hist		[ptr!] ;CvHistogram!	threshold	[decimal!]] imgproc "cvThreshHist"cvCompareHist: cvFunc  ["Compares two histograms"	hist1		[ptr!] ;CvHistogram!	hist2		[ptr!] ;CvHistogram!	method		[integer!]	return:		[decimal!]] imgproc "cvCompareHist"cvCopyHist: cvFunc  ["Copies one histogram to another. Destination histogram is created if the destination pointer is NULL"	src		[ptr!] ;CvHistogram!	dst     [ptr!] ;CvHistogram**] imgproc "cvCopyHist"cvCalcBayesianProb: cvFunc  ["Calculates bayesian probabilistic histograms (each or src and dst is an array of <number> histograms"	src			[ptr!] ;CvHistogram**	number		[integer!]	dst      	[ptr!] ;CvHistogram**] imgproc "cvCalcBayesianProb"cvCalcArrHist: cvFunc ["Calculates array histogram"	arr			[ptr!] ;CvArr!	hist		[ptr!] ;CvHistogram!	accumulate	[integer!]; CV_DEFAULT(0)	mask		[ptr!] ;CvArr! CV_DEFAULT(NULL)] imgproc "cvCalcArrHist" cvCalcHist: func [image  hist  accumulate  mask ] ["Calculates array histogram (image : IplImage**)"    cvCalcArrHist image hist accumulate mask]cvCalcArrBackProject: cvFunc  ["Calculates back project"	image	[ptr!]	;CvArr! ; ** CvArr	dst		[ptr!]	;CvArr!; * CvArr	hist	[ptr!] 	;CvHistogram] imgproc "cvCalcArrBackProject" cvCalcBackProject: func [image dst hist] [cvCalcArrBackProject image dst hist]                   cvCalcArrBackProjectPatch: cvFunc   ["Does some sort of template matching but compares histograms of template and each window location"	image		[ptr!]		;CvArr! ; ** CvArr	dst			[ptr!]		;CvArr! ; * CvArr	range_w		[integer!] 	; _CvSize	range_h		[integer!] 	; _CvSize	hist		[ptr!] 		;CvHistogram	method		[integer!]	factor		[decimal!]] imgproc "cvCalcArrBackProjectPatch"cvCalcBackProjectPatch: func [image dst range hist method factor] [            cvCalcArrBackProjectPatch image dst range hist method factor   ]cvCalcProbDensity:  ["calculates probabilistic density (divides one histogram by another)"	hist1		[ptr!] 		;CvHistogram	hist2		[ptr!] 		;CvHistogram	dst_hist	[ptr!] 		;CvHistogram	scale		[decimal!]] imgproc "cvCalcProbDensity"cvEqualizeHist: cvFunc  ["equalizes histogram of 8-bit single-channel image"	src		[ptr!]	; [struct! (first CvArr!)]	dst		[ptr!]	; [struct! (first CvArr!)]] imgproc "cvEqualizeHist"cvDistTransform: cvFunc   ["Applies distance transform to binary image"	src                 [ptr!]		;CvArr!	dst                 [ptr!]		;CvArr!	distance_type       [integer!] ;CV_DEFAULT(CV_DIST_L2)	mask_size           [integer!] ;CV_DEFAULT(3)	mask                [ptr!]		; float ptr CV_DEFAULT(NULL)	labels              [ptr!]		;CvArr! ; CV_DEFAULT(NULL) ] imgproc "cvDistTransform";Applies fixed-level threshold to grayscale image.;This is a basic operation applied before retrieving contourscvThreshold: cvFunc   ["Applies fixed-level threshold to grayscale image"	src                 [ptr!] ; CvArr!	dst                 [ptr!] ; CvArr!	threshold           [decimal!]	max_value           [decimal!]	threshold_type      [integer!]	return:             [decimal!] ] imgproc "cvThreshold";Applies adaptive threshold to grayscale image.;The two parameters for methods CV_ADAPTIVE_THRESH_MEAN_C and CV_ADAPTIVE_THRESH_GAUSSIAN_C are:;neighborhood size (3, 5, 7 etc.), and a constant subtracted from mean (...,-3,-2,-1,0,1,2,3,...)cvAdaptiveThreshold: cvFunc  ["Applies adaptive threshold to grayscale image."	src                 [ptr!] ;CvArr!	dst                 [ptr!] ;CvArr!	max_value           [decimal!]	adaptive_method     [integer!]  ;CV_DEFAULT(CV_ADAPTIVE_THRESH_MEAN_C)	threshold_type      [integer!]  ; CV_DEFAULT(CV_THRESH_BINARY)	block_size          [integer!]  ; CV_DEFAULT(3)	param1              [decimal!]    ; CV_DEFAULT(5))] imgproc "cvAdaptiveThreshold"cvFloodFill: cvFunc   ["Fills the connected component until the color difference gets large enough"	image               [ptr!];         CvArr!	seed_point_x        [integer!]	seed_point_y        [integer!]	new_val0            [decimal!]	;CvScalar	new_val1            [decimal!]	;CvScalar	new_val2            [decimal!]	;CvScalar	new_val3            [decimal!]	;CvScalar	lo_diff0            [decimal!]	;CvScalar CV_DEFAULT(cvScalarAll(0))	lo_diff1            [decimal!]	;CvScalar CV_DEFAULT(cvScalarAll(0)	lo_diff2            [decimal!]	;CvScalar CV_DEFAULT(cvScalarAll(0)	lo_diff3            [decimal!]	;CvScalar CV_DEFAULT(cvScalarAll(0)	up_diff0            [decimal!]	;CvScalar CV_DEFAULT(cvScalarAll(0))	up_diff1            [decimal!]	;CvScalar CV_DEFAULT(cvScalarAll(0)	up_diff2            [decimal!]	;CvScalar CV_DEFAULT(cvScalarAll(0)	up_diff3            [decimal!]	;CvScalar CV_DEFAULT(cvScalarAll(0)	comp                [ptr!]		;CvConnectedComp!	flags               [integer!]	;CV_DEFAULT(4)	mask                [ptr!]		;CvArr!    ; CV_DEFAULT(NULL)  ] imgproc "cvFloodFill";*********************** Feature detection  ***************************cvCanny: cvFunc   ["Runs canny edge detector"	image               [ptr!]; [struct! (first CvArr!)]	edges               [ptr!]; [struct! (first CvArr!)]	threshold1          [decimal!]	threshold2          [decimal!]	aperture_size       [integer!] ; CV_DEFAULT(3)] imgproc "cvCanny";Applying threshold to the result gives coordinates of cornerscvPreCornerDetect: cvFunc  ["Calculates constraint image for corner detection Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy."	image               [ptr!]		;CvArr!	edges               [ptr!]		;CvArr!	aperture_size       [integer!] 	;CV_DEFAULT(3)] imgproc "cvPreCornerDetect" cvCornerEigenValsAndVecs: cvFunc  ["Calculates eigen values and vectors of 2x2 gradient covariation matrix at every image pixel"	image               [ptr!]		;CvArr!	eigenvv             [ptr!]		;CvArr!	block_size          [integer!]	aperture_size       [integer!] 	;CV_DEFAULT(3)] imgproc "cvCornerEigenValsAndVecs"cvCornerMinEigenVal: cvFunc   ["Calculates minimal eigenvalue for 2x2 gradient covariation matrix at every image pixel"	image               [ptr!]		;CvArr!	eigenval            [ptr!]		;CvArr!	block_size          [integer!]	aperture_size       [integer!] 	;CV_DEFAULT(3)] imgproc "cvCornerMinEigenVal"cvCornerHarris: cvFunc ["Harris corner detector: Calculates det(M) - k*(trace(M)^2), where M is 2x2 gradient covariation matrix for each pixel"    	image               [ptr!]		;CvArr!	harris_responce     [ptr!]		;CvArr!	block_size          [integer!]	aperture_size       [integer!] 	;CV_DEFAULT(3)	k                   [decimal!]   ;CV_DEFAULT(0.04)] imgproc "cvCornerHarris" cvFindCornerSubPix: cvFunc   ["Adjust corner position using some sort of gradient search"	image               [ptr!]		;CvArr!	corners             [ptr!] 		;CvPoint2D32f! pointer	count               [integer!]	win_w               [integer!] 	;CvSize	win_h               [integer!] 	;CvSize	zero_zone_w         [integer!] 	;CvSize	zero_zone_h         [integer!] 	;CvSize	criteria            [ptr!]		;CvTermCriteria!] imgproc "cvFindCornerSubPix"cvGoodFeaturesToTrack: cvFunc  ["Finds a sparse set of points within the selected region that seem to be easy to track"	image               [ptr!]		;CvArr!	eig_image           [ptr!]		;CvArr!	temp_image          [ptr!]		;CvArr!	corners             [ptr!] 		;CvPoint2D32f! pointer	corner_count        [ptr!] 		;int ptr	quality_level       [decimal!]	min_distance        [decimal!]	mask                [ptr!]		;CvArr!   ;CV_DEFAULT(NULL)	block_size          [integer!] 	;CV_DEFAULT(3)	use_harris          [integer!] 	;CV_DEFAULT(0)	k                   [decimal!]  ;CV_DEFAULT(0.04)] imgproc "cvGoodFeaturesToTrack";Finds lines on binary image using one of several methods.;line_storage is either memory storage or 1 x <max number of lines> CvMat, its;number of columns is changed by the function.; method is one of CV_HOUGH_*;;rho, theta and threshold are used for each of those methods;;param1 ~ line length, param2 ~ line gap - for probabilistic,;param1 ~ srn, param2 ~ stn - for multi-scalecvHoughLines2: cvFunc   ["Finds lines on binary image using one of several methods"	image               [ptr!] 		;CvArr!	line_storage        [ptr!] 		;*void	method              [integer!]	rho                 [decimal!]	theta               [decimal!]	threshold           [integer!]	param1              [decimal!] ;CV_DEFAULT(0)	param2              [decimal!] ;CV_DEFAULT(0)	return:             [ptr!] ;CvSeq!] imgproc "cvHoughLines2"cvHoughCircles: cvFunc   ["Finds circles in the image"	image               [ptr!]	circle_storage      [ptr!] 		;*void	method              [integer!]	dp                  [decimal!]	min_dist            [decimal!]	param1              [decimal!] 	; CV_DEFAULT(100)	param2              [decimal!] 	; CV_DEFAULT(100)	min_radius          [integer!] 	; CV_DEFAULT(0)	max_radius          [integer!]	return:             [ptr!] 		;CvSeq!]imgproc "cvHoughCircles"cvFitLine: cvFunc   ["Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)"	points              [ptr!];         CvArr!	dist_type           [integer!]	param               [decimal!]	reps                [decimal!]	aeps                [decimal!]	line                [ptr!]		;  ptr to float array] imgproc "cvFitLine";/****************************************************************************************\;*                                     Drawing                                            *;\****************************************************************************************/;/****************************************************************************************\;*       Drawing functions work with images/matrices of arbitrary type.                   *;*       For color images the channel order is BGR[A]                                     *;*       Antialiasing is supported only for 8-bit image now.                              *;*       All the functions include parameter color that means rgb value (that may be      *;*       constructed with CV_RGB macro) for color images and brightness                   *;*       for grayscale images.                                                            *;*       If a drawn figure is partially or completely outside of the image, it is clipped.*;\****************************************************************************************/CV_RGB: func [r g b] [cvScalar b g r 0 ]CV_FILLED:	 -1CV_AA:		 16;Draws 4-connected, 8-connected or antialiased line segment connecting two pointscvLine: cvFunc  [	img				[ptr!] ; CvArr!	pt1_x			[integer!]	pt1_y 			[integer!]	pt2_x 			[integer!]	pt2_y 			[integer!]	r				[decimal!]	g				[decimal!]	b				[decimal!]	a				[decimal!]	thickness		[integer!] ;	line_type		[integer!] ;CV_DEFAULT(8)	_shift			[integer!] ;CV_DEFAULT(0)] imgproc "cvLine";Draws a rectangle given two opposite corners of the rectangle (pt1 & pt2),;if thickness<0 (e.g. thickness == CV_FILLED), the filled box is drawn cvRectangle: cvFunc  [	img				[ptr!] ; CvArr!	pt1_x			[integer!]	pt1_y 			[integer!]	pt2_x 			[integer!]	pt2_y 			[integer!]	r				[decimal!]	g				[decimal!]	b				[decimal!]	a				[decimal!]	thickness		[integer!]	line_type		[integer!];CV_DEFAULT(8)	_shift			[integer!];CV_DEFAULT(0)] imgproc "cvRectangle"  ;Draws a rectangle specified by a CvRect structurecvRectangleR: cvFunc [	img				[ptr!] ; CvArr!	x				[integer!]	y 				[integer!]	w 				[integer!]	h 				[integer!]	r				[decimal!]	g				[decimal!]	b				[decimal!]	a				[decimal!]	thickness		[integer!]	line_type		[integer!];CV_DEFAULT(8)	_shift			[integer!];CV_DEFAULT(0)] imgproc "cvRectangleR" cvCircle: cvFunc  [	img				[ptr!] ; CvArr!	center_x		[integer!]	center_y 		[integer!]	radius			[integer!]	r				[decimal!]	g				[decimal!]	b				[decimal!]	a				[decimal!]	thickness		[integer!];CV_DEFAULT(1)	line_type		[integer!];CV_DEFAULT(8)	_shift			[integer!];CV_DEFAULT(0)] imgproc "cvCircle"{Draws ellipse outline, filled ellipse, elliptic arc or filled elliptic sector,depending on <thickness>, <start_angle> and <end_angle> parameters. The resultant figureis rotated by <angle>. All the angles are in degrees}cvEllipse: cvFunc  [	img				[ptr!] ; CvArr!	center_x		[integer!]	center_y 		[integer!]	width			[integer!]	height			[integer!]	angle			[decimal!]	start_angle		[decimal!]	end_angle		[decimal!]	r				[decimal!]	g				[decimal!]	b				[decimal!]	a				[decimal!]	thickness		[integer!];CV_DEFAULT(1)	line_type		[integer!];CV_DEFAULT(8)	_shift			[integer!];CV_DEFAULT(0)] imgproc "cvEllipse"cvEllipseBox: func [ptr center [pair!] size [pair!] angle [number!] color [tuple!] thickness [integer!] lineType [integer!] offset [integer!]/local r g b a axes][ tmp: tocvRGB color r: tmp/3 g: tmp/2 b: tmp/1 a: tmp/4  axes: make struct! cvSize! none  axes/width: first size   axes/height: second size  cvEllipse ptr center/x center/y axes/width axes/height to-decimal angle 0 360 r g b a thickness lineType offset]; Fills convex or monotonous polygon.cvFillConvexPoly: cvFunc  [ 	img				[ptr!] ; CvArr!	pts				[integer!] ; pointer to array of points 	npts			[integer!] ; nb of vertices	r				[decimal!]	g				[decimal!]	b				[decimal!]	a				[decimal!]	line_type		[integer!];CV_DEFAULT(8)	_shift			[integer!];CV_DEFAULT(0)] imgproc "cvFillConvexPoly"	;Fills an area bounded by one or more arbitrary polygonscvFillPoly: cvFunc  [ 	img				[ptr!] ; CvArr!	pts				[integer!] ; pointer to array of array of points 	npts			[integer!] ;pointer nb of points by polygons	contours		[integer!] ; nb of polygons to draw	r				[decimal!]	g				[decimal!]	b				[decimal!]	a				[decimal!]	line_type		[integer!];CV_DEFAULT(8)	_shift			[integer!];CV_DEFAULT(0)] imgproc "cvFillPoly";Draws one or more polygonal curvescvPolyLine: cvFunc  [ 	img				[ptr!] ; CvArr!	pts				[integer!] ; pointer to array of points 	npts			[integer!] ;nb of vertices	contours		[integer!] ; nb of polygons	is_closed		[integer!] ; 0 or 1 to close the polygon	r				[decimal!]	g				[decimal!]	b				[decimal!]	a				[decimal!]	thickness 		[integer!];CV_DEFAULT(1)	line_type		[integer!];CV_DEFAULT(8)	_shift			[integer!];CV_DEFAULT(0)] imgproc "cvPolyLine"alias 'cvRectangle "cvDrawRect" alias 'cvLine "cvDrawLine"alias 'cvCircle "cvDrawCircle"alias 'cvEllipse "cvDrawEllipse"alias 'cvPolyLine "cvDrawPolyLine";Clips the line segment connecting *pt1 and *pt2 by the rectangular window (0<=x<img_size.width, 0<=y<img_size.height).cvClipLine: cvFunc  [ 	width 		[integer!];x CvSize	height 		[integer!]; y CvSize	*pt1		[integer!]; pointer to cvPoint	*pt2		[integer!] ; pointer to cvPoint	return:		[integer!]] imgproc "cvClipLine"{Initializes line iterator. Initially, line_iterator->ptr will pointto pt1 (or pt2, see left_to_right description) location in the image.Returns the number of pixels on the line between the ending points}cvInitLineIterator: cvFunc  [ 	img				[ptr!] ; CvArr!	pt1_x			[integer!]	pt1_y 			[integer!]	pt2_x 			[integer!]	pt2_y 			[integer!]	line_iterator   [ptr!]; CvLineIterator ; pointer 	connectivity	[integer!] ;CV_DEFAULT(8)	left_to_right	[integer!] ;CV_DEFAULT(0)	return:			[integer!]] imgproc "cvInitLineIterator";Moves iterator to the next line point CV_NEXT_LINE_POINT: func [line_iterator] [	either line_iterator/err < 0 [_line_iterator_mask: -1] [_line_iterator_mask: 0]	line_iterator/err: line_iterator/err + line_iterator/delta + (line_iterator/plus_delta AND _line_iterator_mask)	line_iterator/ptr: line_iterator/ptr + line_iterator/minus_step + (line_iterator/plus_step AND _line_iterator_mask)];/basic font types */ CV_FONT_HERSHEY_SIMPLEX:         0 CV_FONT_HERSHEY_PLAIN:           1 CV_FONT_HERSHEY_DUPLEX:          2 CV_FONT_HERSHEY_COMPLEX:         3  CV_FONT_HERSHEY_TRIPLEX:         4 CV_FONT_HERSHEY_COMPLEX_SMALL:   5 CV_FONT_HERSHEY_SCRIPT_SIMPLEX:  6 CV_FONT_HERSHEY_SCRIPT_COMPLEX:  7 ; font flags CV_FONT_ITALIC:                 16  CV_FONT_VECTOR0:    CV_FONT_HERSHEY_SIMPLEX; Font structure CvFont!: make struct! [    font_face 	[integer!]; /* =CV_FONT_* */    ascii 		[integer!]; ptr!-ptr! /* font data and metrics */    greek		[integer!]; ptr!-ptr!    cyrillic	[integer!]; ptr!-ptr!    hscale 		[decimal!]    vscale		[decimal!]    shear		[decimal!] ; /* slope coefficient: 0 - normal, >0 - italic */    thickness	[integer!] ; /* letters thickness */    dx			[decimal!]; /* horizontal interval between letters */    line_type	[integer!];] none;Initializes font structure used further in cvPutTextcvInitFont: cvFunc  [ 	*font				[ptr!]; CvFont ; pointer to fonts	font_face			[integer!]	hscale				[decimal!]	vscale				[decimal!]	shear				[decimal!]; CV_DEFAULT(0) ;italic	thickness			[integer!]; CV_DEFAULT(1)	line_type			[integer!];CV_DEFAULT(8))] imgproc "cvInitFont" cvFont: func [scale thickness][    font: make struct! CvFont! none;    cvInitFont font CV_FONT_HERSHEY_PLAIN scale scale 0 thickness CV_AA    return font;]; Renders text stroke with specified font and color at specified location. CvFont should be initialized with cvInitFontcvPutText: cvFunc  [  	img				[ptr!] ; CvArr!	text			[string!]	orgx			[integer!]	orgy			[integer!]	font			[ptr!]; CvFont; &font pointer 	r				[decimal!]	g				[decimal!]	b				[decimal!]	a				[decimal!]] imgproc "cvPutText";Calculates bounding box of text stroke (useful for alignment)cvGetTextSize: cvFunc  [  	text			[string!]	;font			[integer!]; pointer	font			[ptr!]; CvFont; pointer	text_size		[ptr!]; pointer to cvSize*	baseline		[ptr!]; pointer] imgproc "cvGetTextSize" { Unpacks color value, if arrtype is CV_8UC?, <color> is treated as   packed color value, otherwise the first channels (depending on arrtype)   of destination scalar are set to the same value = <color> }cvColorToScalar: cvFunc  [  	packed_color	[decimal!]	arrtype			[integer!]	return: 		[ptr!]		] imgproc "cvColorToScalar" {Returns the polygon points which make up the given ellipse.  The ellipse is define bythe box of size 'axes' rotated 'angle' around the 'center'.  A partial sweepof the ellipse arc can be done by spcifying arc_start and arc_end to be somethingother than 0 and 360, respectively.  The input array 'pts' must be large enough tohold the result.  The total number of points stored into 'pts' is returned by this function.}cvEllipse2Poly: cvFunc  [  	center_x			[integer!];cvPoint	center_y			[integer!];cvPoint	axe_x				[integer!];cvSize	axe_y				[integer!];cvSize	angle				[integer!]	arc_start			[integer!]	arc_end				[integer!]	pts					[integer!]; pointer to cvPoints	delta				[integer!]; 	return:				[integer!]] imgproc "cvEllipse2Poly"      ;Draws contour outlines or filled interiors on the imagecvDrawContours: cvFunc  [ 	img				[ptr!] ; CvArr!	contour			[ptr!]; CvSeq	er				[decimal!]	eg				[decimal!]	eb				[decimal!]	ea				[decimal!]	hr				[decimal!]	hg				[decimal!]	hb				[decimal!]	ha				[decimal!]	thickness 		[integer!];CV_DEFAULT(1)	line_type		[integer!];CV_DEFAULT(8)	offset_x		[integer!];CV_DEFAULT(0)	offset_y		[integer!];CV_DEFAULT(0)] imgproc "cvDrawContours"