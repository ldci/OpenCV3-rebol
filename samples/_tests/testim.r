#! /usr/local/bin/rebolrebol []do %../../opencv.rset 'appDir what-dir wname: "OpenCV and Rebol"depth: IPL_DEPTH_32F; size: make struct! CvSize! [640 480]s: to-binary second sizeprint ["Memory: " stats / (10 ** 6) ]isource: cvCreateImage size/width size/height depth 3cvZero isourcecopie: cvCloneImage isourceprint cvCheckArr copie 0 0 0type: make decimal! 0.0print ["image? : " CV_IS_IMAGE isource]print ["pixel 0x0 value? " CV_IMAGE_ELEM isource type 0 0]print ["Memory: " stats / (10 ** 6) ]cvNamedWindow wname CV_WINDOW_AUTOSIZEcvShowImage wname isourcehandle: cvGetWindowHandle wnameprint newlineprint ["Window Name: " cvGetWindowName handle]print ["Size: " cvGetSize isource ]print ["Coi: " cvGetImageCOI isource]print ["Roi: " cvGetImageROI isource]; test GetRawDatastep: make struct! int-ptr! [0]&step: &pointer stepdata: make struct! int-ptr! [0]&data: &pointer data size: make struct! cvSize! reduce [0 0]&size: &pointer sizecvGetRawData isource &data &step &size; creates a ROI 20x20 at 5x5roi: cvGetImageROI isourcecoi: cvGetImageCOI isourcerect: cvRect 5 5 20 20ret: cvRectToROI rect coiprint ["New Roi: "  second ret] ; now uses cvROIToRect to restore ROInroi: make struct! IplROI! [0 0 0 640 480]ret: cvROIToRect nroiprint ["New Roi: "  second ret] ; test cvTermCriteriaprint [second cvTermCriteria CV_TERMCRIT_ITER 10 0.5]; test cvPointp: cvPoint2D32f 10 10print [ second cvPointFrom32f p]; test cvSliceprint [second cvSlice 1 10 ]cvWaitKey 0cvDestroyWindow wnameprint "Window is destroyed"print stats / (10 ** 6) print "Memoire liberee"free-mem isourceprint stats / (10 ** 6) 